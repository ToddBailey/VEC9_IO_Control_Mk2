   1               		.file	"vec9_io.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__CCP__ = 0x34
   7               	__tmp_reg__ = 0
   8               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
  11               		.cfi_sections	.debug_frame
  13               	CCPWrite:
  14               	.LFB6:
  15               		.file 1 "vec9_io.c"
   1:vec9_io.c     **** // VEC9 Input/Output Adapter
   2:vec9_io.c     **** // Todd Michael Bailey
   3:vec9_io.c     **** 
   4:vec9_io.c     **** //=============================
   5:vec9_io.c     **** // Atmel AVR ATXmega64a3
   6:vec9_io.c     **** // 20MHz Silicon Oscillator (LTC6905)
   7:vec9_io.c     **** // GCC 4.8.2
   8:vec9_io.c     **** //==============================
   9:vec9_io.c     **** 
  10:vec9_io.c     **** 
  11:vec9_io.c     **** /*
  12:vec9_io.c     **** Description:
  13:vec9_io.c     **** ==============================================================================
  14:vec9_io.c     **** Updated VEC9 front panel hardware.
  15:vec9_io.c     **** This unit removes all the serial/parallel adapters and hardware hanging around from the original de
  16:vec9_io.c     **** Drivers for incandescents and the siren are added to the board.
  17:vec9_io.c     **** Connectorization hopefully makes sense now.
  18:vec9_io.c     **** (Note -- according to at least one datasheet a DB15 contact carries 2A, so we can use them for inca
  19:vec9_io.c     **** 
  20:vec9_io.c     **** 
  21:vec9_io.c     **** NOTE -- this is currently the second of two IO controllers (and the second design).  "The Old One" 
  22:vec9_io.c     **** 
  23:vec9_io.c     **** NOTE -- the VEC9 prototype was based on the older PS2 adapter which used serial communications to a
  24:vec9_io.c     **** The I/O controllers proper (both old and new) use the M1 Abrams Gunner's Control Handle and have ge
  25:vec9_io.c     **** 
  26:vec9_io.c     **** The "start of message" bytes are PS2 related, and can (maybe should) change.  There may be other PS
  27:vec9_io.c     **** 
  28:vec9_io.c     **** Inputs:
  29:vec9_io.c     **** ----------------
  30:vec9_io.c     **** Yoke Pitch (analog)
  31:vec9_io.c     **** Yoke Roll (analog)
  32:vec9_io.c     **** Yoke Triggers Right (3)
  33:vec9_io.c     **** Yoke Triggers Left (3)
  34:vec9_io.c     **** Safety Switches (4)
  35:vec9_io.c     **** Illuminated Switches (2 -- old units were NC, annoying)
  36:vec9_io.c     **** Coin Switch (1) (replaced old placeholder for key switch)
  37:vec9_io.c     **** Test Mode / Service Menu switch (1)
  38:vec9_io.c     **** Total: 14 + 2
  39:vec9_io.c     **** 
  40:vec9_io.c     **** Outputs:
  41:vec9_io.c     **** -----------------
  42:vec9_io.c     **** Flight Indicators (10, incandescent)
  43:vec9_io.c     **** Illuminated Switches (2, incandescent)
  44:vec9_io.c     **** Air Horn (1, motor-ish)
  45:vec9_io.c     **** Red/Green LED Switch Panel Indicators (8)
  46:vec9_io.c     **** 
  47:vec9_io.c     **** Total: 21
  48:vec9_io.c     **** 
  49:vec9_io.c     **** Total IO = 37
  50:vec9_io.c     **** 
  51:vec9_io.c     **** (On the old unit, in order to get all these, we drive the R/G LEDs with a serial-parallel converter
  52:vec9_io.c     **** 
  53:vec9_io.c     **** The new unit routes to different IO pins, and also adds 6 spare I/O lines and one spare ADC line.
  54:vec9_io.c     **** 
  55:vec9_io.c     **** ==================================================================================================
  56:vec9_io.c     **** ==================================================================================================
  57:vec9_io.c     **** 
  58:vec9_io.c     **** Serial Data Format:
  59:vec9_io.c     **** ---------------------
  60:vec9_io.c     **** All serial exchanges are at 38400,8,1,N.
  61:vec9_io.c     **** 
  62:vec9_io.c     **** PC-To-Xmega (Poll Request / Set outputs):
  63:vec9_io.c     **** --------------------------------------------
  64:vec9_io.c     **** 0x42 outputsMsb outputsMiddle outputsLsb
  65:vec9_io.c     **** 
  66:vec9_io.c     **** 
  67:vec9_io.c     **** Reply from XMEGA:
  68:vec9_io.c     **** ------------------------
  69:vec9_io.c     **** 0x41 switchMsb switchLsb 0 0 analogRoll analogPitch
  70:vec9_io.c     **** 
  71:vec9_io.c     **** // Tue Apr 26 18:05:25 EDT 2016
  72:vec9_io.c     **** // Bitmask VEC9 Host is expecting:
  73:vec9_io.c     **** // ----------------------------
  74:vec9_io.c     **** //	15		14		13		12		11		10		9		8		7		6		5		4		3		2		1		0
  75:vec9_io.c     **** //	(x)		(x) 	Test	Coin	Pbtn1	Pbtn0	Tog3	Tog2	Tog1	Tog0	LGrip	LThumb	LTrig	Rgrip	Rthumb	RTrig
  76:vec9_io.c     **** 
  77:vec9_io.c     **** 
  78:vec9_io.c     **** 
  79:vec9_io.c     **** */
  80:vec9_io.c     **** 
  81:vec9_io.c     **** #include	"includes.h"
  82:vec9_io.c     **** 
  83:vec9_io.c     **** #define		BUILD_DATE						__DATE__	// String we print when we want to know when we last updated this
  84:vec9_io.c     **** 
  85:vec9_io.c     **** // --------------------------
  86:vec9_io.c     **** // Defines for this file:
  87:vec9_io.c     **** // --------------------------
  88:vec9_io.c     **** 
  89:vec9_io.c     **** // --------------------------
  90:vec9_io.c     **** // Globals for this file:
  91:vec9_io.c     **** // --------------------------
  92:vec9_io.c     **** 
  93:vec9_io.c     **** // --------------------------
  94:vec9_io.c     **** // Function Prototypes:
  95:vec9_io.c     **** // --------------------------
  96:vec9_io.c     **** 
  97:vec9_io.c     **** static void CCPWrite( volatile uint8_t * address, uint8_t value );
  98:vec9_io.c     **** 
  99:vec9_io.c     **** //-----------------------------------------------------------------------
 100:vec9_io.c     **** //-----------------------------------------------------------------------
 101:vec9_io.c     **** // State Machine Functions.
 102:vec9_io.c     **** //-----------------------------------------------------------------------
 103:vec9_io.c     **** //-----------------------------------------------------------------------
 104:vec9_io.c     **** 
 105:vec9_io.c     **** void SetState(STATE_FUNC *newState)		// Sets the device to a new state, assumes it should begin at 
 106:vec9_io.c     **** {
 107:vec9_io.c     **** 	State=newState;
 108:vec9_io.c     **** 	subState=SS_0;
 109:vec9_io.c     **** }
 110:vec9_io.c     **** 
 111:vec9_io.c     **** 
 112:vec9_io.c     **** // --------------------------
 113:vec9_io.c     **** // Error Recovery:
 114:vec9_io.c     **** // --------------------------
 115:vec9_io.c     **** 
 116:vec9_io.c     **** ISR(__vector_default)
 117:vec9_io.c     **** {
 118:vec9_io.c     ****     //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went 
 119:vec9_io.c     **** 	//	printf("Buggy Interrupt Generated!  Flags = ");
 120:vec9_io.c     **** 	//  printf("*****put interrupt register values here****");
 121:vec9_io.c     **** 
 122:vec9_io.c     **** 	// Hang, or reset part, or whatever
 123:vec9_io.c     **** 
 124:vec9_io.c     **** 	asm("jmp 0000");			// head to normal reset vector, should never happen
 125:vec9_io.c     **** }
 126:vec9_io.c     **** 
 127:vec9_io.c     **** //-----------------------------------------------------------------------
 128:vec9_io.c     **** //-----------------------------------------------------------------------
 129:vec9_io.c     **** // Software clock / PerIrq init
 130:vec9_io.c     **** //-----------------------------------------------------------------------
 131:vec9_io.c     **** //-----------------------------------------------------------------------
 132:vec9_io.c     **** 
 133:vec9_io.c     **** static void InitSoftclock(void)
 134:vec9_io.c     **** // We're using PORTE's timer 0 for this.
 135:vec9_io.c     **** // Look at the value of SECOND define, and set number of periodic interrupt requests per second.
 136:vec9_io.c     **** // Affects watchdog, too.
 137:vec9_io.c     **** {
 138:vec9_io.c     **** 	systemTicks=0;
 139:vec9_io.c     **** 
 140:vec9_io.c     **** 	PR.PRPE&=~PR_TC0_bm;		// Turn on timer counter zero for porte
 141:vec9_io.c     **** 
 142:vec9_io.c     **** 	TCE0.CCA=0;						// Compare match 0
 143:vec9_io.c     **** 	TCE0.CNT=0;						// Set Count Value to 0.
 144:vec9_io.c     **** 	TCE0.PER=(F_CPU/SECOND);		// Set period for this timer (max count)
 145:vec9_io.c     **** 
 146:vec9_io.c     **** 	TCE0.CTRLB=0;					// No compares/captures enabled, and no waveforms
 147:vec9_io.c     **** 
 148:vec9_io.c     **** 	TCE0.INTFLAGS=0xFF;						// Clear the interrupt flags
 149:vec9_io.c     **** //	TCE0.INTCTRLA=TC_OVFINTLVL_HI_gc;		// Set wdt overflow interrupt (high priority)
 150:vec9_io.c     **** 	TCE0.INTCTRLA=TC_OVFINTLVL_LO_gc;		// Set wdt overflow interrupt (low priority)
 151:vec9_io.c     **** 	TCE0.INTCTRLB=0;						// No CC ints
 152:vec9_io.c     **** 	TCE0.CTRLA=TC_CLKSEL_DIV1_gc;			// Start the timer with a clock division of 1.
 153:vec9_io.c     **** }
 154:vec9_io.c     **** 
 155:vec9_io.c     **** //-----------------------------------------------------------------------
 156:vec9_io.c     **** //-----------------------------------------------------------------------
 157:vec9_io.c     **** // Periodic Interrupt Request
 158:vec9_io.c     **** //-----------------------------------------------------------------------
 159:vec9_io.c     **** //-----------------------------------------------------------------------
 160:vec9_io.c     **** 
 161:vec9_io.c     **** ISR(TCE0_OVF_vect)
 162:vec9_io.c     **** {
 163:vec9_io.c     **** 	systemTicks++;					// Increment the system ticks.
 164:vec9_io.c     **** }
 165:vec9_io.c     **** 
 166:vec9_io.c     **** //-----------------------------------------------------------------------
 167:vec9_io.c     **** //-----------------------------------------------------------------------
 168:vec9_io.c     **** // Protected Register Access Functions
 169:vec9_io.c     **** //-----------------------------------------------------------------------
 170:vec9_io.c     **** //-----------------------------------------------------------------------
 171:vec9_io.c     **** 
 172:vec9_io.c     **** static void CCPWrite(volatile uint8_t * address, uint8_t value)
 173:vec9_io.c     **** // Assembly helper function which writes the Config Change Protection register and immediately the 
 174:vec9_io.c     **** // NOTE -- this only writes protected IO registers, not SPM/LPM.
 175:vec9_io.c     **** // Cribbed more or less from AVR1003, with the non-avrgcc #if statements taken out.
 176:vec9_io.c     **** {
  16               		.loc 1 176 0
  17               		.cfi_startproc
  18               	.LVL0:
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 16, -2
  23               	/* prologue: function */
  24               	/* frame size = 0 */
  25               	/* stack size = 1 */
  26               	.L__stack_usage = 1
  27 0002 9C01      		movw r18,r24
 177:vec9_io.c     **** 	unsigned char
 178:vec9_io.c     **** 		sreg;
 179:vec9_io.c     **** 
 180:vec9_io.c     **** 	sreg=SREG;		// Pause interrupts
  28               		.loc 1 180 0
  29 0004 9FB7      		in r25,__SREG__
  30               	.LVL1:
 181:vec9_io.c     **** 	cli();
  31               		.loc 1 181 0
  32               	/* #APP */
  33               	 ;  181 "vec9_io.c" 1
  34 0006 F894      		cli
  35               	 ;  0 "" 2
  36               	.LVL2:
 182:vec9_io.c     **** 
 183:vec9_io.c     **** 	volatile uint8_t * tmpAddr = address;	// Redefine this locally (look this up, not sure why)
 184:vec9_io.c     **** 	RAMPZ = 0;								// Clear third Z indirect addressing reg
  37               		.loc 1 184 0
  38               	/* #NOAPP */
  39 0008 1BBE      		out __RAMPZ__,__zero_reg__
 185:vec9_io.c     **** 
 186:vec9_io.c     **** 	asm volatile(
  40               		.loc 1 186 0
  41               	/* #APP */
  42               	 ;  186 "vec9_io.c" 1
  43 000a F901      		movw r30,  r18
  44 000c 08ED      		ldi  r16,  216
  45 000e 04BF      		out   52, r16
  46 0010 6083      		st     Z,  r22
  47               		
  48               	 ;  0 "" 2
 187:vec9_io.c     **** 		"movw r30,  %0"	      "\n\t"		// Store our temp address
 188:vec9_io.c     **** 		"ldi  r16,  %2"	      "\n\t"		// Store our CCP signature
 189:vec9_io.c     **** 		"out   %3, r16"	      "\n\t"		// Write signature to CCP register
 190:vec9_io.c     **** 		"st     Z,  %1"       "\n\t"		// Put the passed value into the passed address (happens one cycle 
 191:vec9_io.c     **** 		:
 192:vec9_io.c     **** 		: "r" (tmpAddr), "r" (value), "M" (CCP_IOREG_gc), "i" (&CCP)		// variables for above
 193:vec9_io.c     **** 		: "r16", "r30", "r31"												// Clobber list
 194:vec9_io.c     **** 		);
 195:vec9_io.c     **** 
 196:vec9_io.c     **** 	SREG=sreg;		// Restore interrupts
  49               		.loc 1 196 0
  50               	/* #NOAPP */
  51 0012 9FBF      		out __SREG__,r25
  52               	/* epilogue start */
 197:vec9_io.c     **** }
  53               		.loc 1 197 0
  54 0014 0F91      		pop r16
  55 0016 0895      		ret
  56               		.cfi_endproc
  57               	.LFE6:
  59               	.global	UartPutChar
  61               	UartPutChar:
  62               	.LFB7:
 198:vec9_io.c     **** 
 199:vec9_io.c     **** //-----------------------------------------------------------------------
 200:vec9_io.c     **** //-----------------------------------------------------------------------
 201:vec9_io.c     **** // Printf support functions
 202:vec9_io.c     **** //-----------------------------------------------------------------------
 203:vec9_io.c     **** //-----------------------------------------------------------------------
 204:vec9_io.c     **** 
 205:vec9_io.c     **** int UartPutChar(char c, FILE *stream)		// Associating this with FILE makes this link to stdout and 
 206:vec9_io.c     **** // Note -- this implementation pulls in ALL KINDS of garbage from standard C libraries and leads to
 207:vec9_io.c     **** // Re-write it when you have time.
 208:vec9_io.c     **** {
  63               		.loc 1 208 0
  64               		.cfi_startproc
  65               	.LVL3:
  66 0018 CF93      		push r28
  67               	.LCFI1:
  68               		.cfi_def_cfa_offset 3
  69               		.cfi_offset 28, -2
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 1 */
  73               	.L__stack_usage = 1
  74 001a C82F      		mov r28,r24
 209:vec9_io.c     **** 	if(c=='\n')
  75               		.loc 1 209 0
  76 001c 8A30      		cpi r24,lo8(10)
  77 001e 01F4      		brne .L4
 210:vec9_io.c     **** 	{
 211:vec9_io.c     **** 		UartPutChar('\r', stream);				// Always follow a new line with a carriage return.
  78               		.loc 1 211 0
  79 0020 8DE0      		ldi r24,lo8(13)
  80               	.LVL4:
  81 0022 0E94 0000 		call UartPutChar
  82               	.LVL5:
  83               	.L4:
 212:vec9_io.c     **** 	}
 213:vec9_io.c     **** 
 214:vec9_io.c     **** 	while(!(USARTF0.STATUS&USART_DREIF_bm))		// Hang here until there is room in the transmit buffer (
  84               		.loc 1 214 0 discriminator 1
  85 0026 8091 A10B 		lds r24,2977
  86 002a 85FF      		sbrs r24,5
  87 002c 00C0      		rjmp .L4
 215:vec9_io.c     **** 	{
 216:vec9_io.c     **** 		;
 217:vec9_io.c     **** 	}
 218:vec9_io.c     **** 	USARTF0.DATA = c;							// Then xmit the character you've been passed.
  88               		.loc 1 218 0
  89 002e C093 A00B 		sts 2976,r28
 219:vec9_io.c     **** 
 220:vec9_io.c     **** 	return(0);									// Returning an int makes this function play with printf() (no errors).
 221:vec9_io.c     **** }
  90               		.loc 1 221 0
  91 0032 80E0      		ldi r24,0
  92 0034 90E0      		ldi r25,0
  93               	/* epilogue start */
  94 0036 CF91      		pop r28
  95               	.LVL6:
  96 0038 0895      		ret
  97               		.cfi_endproc
  98               	.LFE7:
 101               	SetOutputs:
 102               	.LFB17:
 222:vec9_io.c     **** 
 223:vec9_io.c     **** //-----------------------------------------------------------------------
 224:vec9_io.c     **** //-----------------------------------------------------------------------
 225:vec9_io.c     **** // Serial Functions
 226:vec9_io.c     **** //-----------------------------------------------------------------------
 227:vec9_io.c     **** //-----------------------------------------------------------------------
 228:vec9_io.c     **** // NOTE:  It might be smart to dump anything partially received when the transmitter begins transmi
 229:vec9_io.c     **** // These talk to the gateway.
 230:vec9_io.c     **** 
 231:vec9_io.c     **** #define		SERIAL_USART		USARTF0
 232:vec9_io.c     **** #define		MAX_RX_FIFO_BYTES	64
 233:vec9_io.c     **** 
 234:vec9_io.c     **** static volatile unsigned char
 235:vec9_io.c     **** 	txBuffer[16],
 236:vec9_io.c     **** 	txBufferIndex,
 237:vec9_io.c     **** 	txBytesToSend,
 238:vec9_io.c     **** 	rxFifo[MAX_RX_FIFO_BYTES],
 239:vec9_io.c     **** 	fifoReadPointer,
 240:vec9_io.c     **** 	fifoWritePointer,
 241:vec9_io.c     **** 	dump,				// Keep me volatile
 242:vec9_io.c     **** 	bytesInRxFifo;
 243:vec9_io.c     **** 
 244:vec9_io.c     **** ISR(USARTF0_RXC_vect)
 245:vec9_io.c     **** // When we receive a byte via serial, stick it in the FIFO.
 246:vec9_io.c     **** {
 247:vec9_io.c     **** 	if(bytesInRxFifo<MAX_RX_FIFO_BYTES)
 248:vec9_io.c     **** 	{
 249:vec9_io.c     **** 		rxFifo[fifoWritePointer]=SERIAL_USART.DATA;	// Put data in fifo at current write pointer
 250:vec9_io.c     **** 		fifoWritePointer++;							// Move write pointer forward
 251:vec9_io.c     **** 		if(fifoWritePointer>=MAX_RX_FIFO_BYTES)		// Roll write pointer around end of ring buffer if neede
 252:vec9_io.c     **** 		{
 253:vec9_io.c     **** 			fifoWritePointer=0;
 254:vec9_io.c     **** 		}
 255:vec9_io.c     **** 		bytesInRxFifo++;							// One more byte in the fifo
 256:vec9_io.c     **** 	}
 257:vec9_io.c     **** 	else
 258:vec9_io.c     **** 	{
 259:vec9_io.c     **** 		dump=SERIAL_USART.DATA;		// For whatever reason, writing a one to the flag here doesn't seem to w
 260:vec9_io.c     **** 	}
 261:vec9_io.c     **** }
 262:vec9_io.c     **** 
 263:vec9_io.c     **** static bool	RxFifoNotEmpty(void)
 264:vec9_io.c     **** // Return true if there are unread data in the fifo
 265:vec9_io.c     **** {
 266:vec9_io.c     **** 	unsigned char
 267:vec9_io.c     **** 		sreg;
 268:vec9_io.c     **** 	bool
 269:vec9_io.c     **** 		retVal;
 270:vec9_io.c     **** 
 271:vec9_io.c     **** 	sreg=SREG;
 272:vec9_io.c     **** 	cli();
 273:vec9_io.c     **** 
 274:vec9_io.c     **** 	retVal=false;
 275:vec9_io.c     **** 	if(bytesInRxFifo)	// Got anything in fifo?
 276:vec9_io.c     **** 	{
 277:vec9_io.c     **** 		retVal=true;
 278:vec9_io.c     **** 	}
 279:vec9_io.c     **** 
 280:vec9_io.c     **** 	SREG=sreg;
 281:vec9_io.c     **** 	return(retVal);
 282:vec9_io.c     **** }
 283:vec9_io.c     **** 
 284:vec9_io.c     **** unsigned char GetByteFromRxFifo(void)
 285:vec9_io.c     **** // Returns bytes from the RS485 fifo in the order they were collected.
 286:vec9_io.c     **** {
 287:vec9_io.c     **** 	unsigned char
 288:vec9_io.c     **** 		sreg,
 289:vec9_io.c     **** 		theByte;
 290:vec9_io.c     **** 
 291:vec9_io.c     **** 	sreg=SREG;
 292:vec9_io.c     **** 	cli();
 293:vec9_io.c     **** 
 294:vec9_io.c     **** 	if(bytesInRxFifo)	// Got anything in fifo?
 295:vec9_io.c     **** 	{
 296:vec9_io.c     **** 		theByte=rxFifo[fifoReadPointer];
 297:vec9_io.c     **** 		fifoReadPointer++;							// Move pointer forward
 298:vec9_io.c     **** 		if(fifoReadPointer>=MAX_RX_FIFO_BYTES)		// Roll pointer around end of ring buffer if needed
 299:vec9_io.c     **** 		{
 300:vec9_io.c     **** 			fifoReadPointer=0;
 301:vec9_io.c     **** 		}
 302:vec9_io.c     **** 		bytesInRxFifo--;							// One less byte in the fifo
 303:vec9_io.c     **** 
 304:vec9_io.c     **** 		SREG=sreg;
 305:vec9_io.c     **** 		return(theByte);
 306:vec9_io.c     **** 	}
 307:vec9_io.c     **** 	else
 308:vec9_io.c     **** 	{
 309:vec9_io.c     **** 		SREG=sreg;
 310:vec9_io.c     **** 		return(0);		// Should not happen.  If we call this when there are no bytes in the fifo, return 0
 311:vec9_io.c     **** 	}
 312:vec9_io.c     **** }
 313:vec9_io.c     **** 
 314:vec9_io.c     **** static void InitSerialFifos(void)
 315:vec9_io.c     **** {
 316:vec9_io.c     **** 	unsigned char
 317:vec9_io.c     **** 		sreg;
 318:vec9_io.c     **** 
 319:vec9_io.c     **** 	sreg=SREG;
 320:vec9_io.c     **** 	cli();
 321:vec9_io.c     **** 
 322:vec9_io.c     **** 	bytesInRxFifo=0;					// Init ring buffer for RS485 byte reception
 323:vec9_io.c     **** 	fifoWritePointer=0;
 324:vec9_io.c     **** 	fifoReadPointer=0;
 325:vec9_io.c     **** 	txBufferIndex=0;
 326:vec9_io.c     **** 	txBytesToSend=0;
 327:vec9_io.c     **** 	SERIAL_USART.CTRLA=USART_RXCINTLVL_MED_gc;	// Interrupts enabled, medium priority
 328:vec9_io.c     **** 
 329:vec9_io.c     **** 	SREG=sreg;
 330:vec9_io.c     **** }
 331:vec9_io.c     **** 
 332:vec9_io.c     **** //-----------------------------------------------------------------------
 333:vec9_io.c     **** //-----------------------------------------------------------------------
 334:vec9_io.c     **** // Switch functions:
 335:vec9_io.c     **** //-----------------------------------------------------------------------
 336:vec9_io.c     **** //-----------------------------------------------------------------------
 337:vec9_io.c     **** 
 338:vec9_io.c     **** static unsigned int
 339:vec9_io.c     **** 	keyState,
 340:vec9_io.c     **** 	newKeys,
 341:vec9_io.c     **** 	newKeysReleased;
 342:vec9_io.c     **** 
 343:vec9_io.c     **** static void InitSwitches(void)
 344:vec9_io.c     **** // Sets up user input -- any physical switches which need to be debounced.
 345:vec9_io.c     **** // PA5-7 are inputs
 346:vec9_io.c     **** // PB0-7 are all inputs
 347:vec9_io.c     **** // PC0-2 are inputs
 348:vec9_io.c     **** // NOTE -- we invert the data coming in from these pins, so a pressed switch is read as a ONE later
 349:vec9_io.c     **** // NOTE -- For PORTB to work right, JTAG gotta go.
 350:vec9_io.c     **** {
 351:vec9_io.c     **** 	PORTA.DIRCLR=0xE0;									// Top three bits
 352:vec9_io.c     **** 	PORTA.PIN5CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 353:vec9_io.c     **** 	PORTA.PIN6CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 354:vec9_io.c     **** 	PORTA.PIN7CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 355:vec9_io.c     **** 
 356:vec9_io.c     **** 	PORTB.DIRCLR=0xFF;									// All bits
 357:vec9_io.c     **** 	PORTCFG.MPCMASK=0xFF;								// Configure these pins on this port next time we write the config re
 358:vec9_io.c     **** 	PORTB.PIN0CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 359:vec9_io.c     **** 
 360:vec9_io.c     **** 	PORTC.DIRCLR=0x07;									// Bottom three bits
 361:vec9_io.c     **** 	PORTC.PIN0CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 362:vec9_io.c     **** 	PORTC.PIN1CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 363:vec9_io.c     **** 	PORTC.PIN2CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 364:vec9_io.c     **** 
 365:vec9_io.c     **** 	keyState=0;		// No keys pressed
 366:vec9_io.c     **** 	newKeys=0;		// No keys new
 367:vec9_io.c     **** 
 368:vec9_io.c     **** 	SetTimer(TIMER_DEBOUNCE,(SECOND/64));
 369:vec9_io.c     **** }
 370:vec9_io.c     **** 
 371:vec9_io.c     **** 
 372:vec9_io.c     **** // Tue Apr 26 18:05:25 EDT 2016
 373:vec9_io.c     **** // The old application just stuffed the keystate into the serial output, so the switch bits to the 
 374:vec9_io.c     **** // by HandleSwitches().  Since the hardware has changed 
 375:vec9_io.c     **** // There are currently 14 inputs.
 376:vec9_io.c     **** // Bitmask VEC9 is expecting:
 377:vec9_io.c     **** // ----------------------------
 378:vec9_io.c     **** //	15		14		13		12		11		10		9		8		7		6		5		4		3		2		1		0
 379:vec9_io.c     **** //	(x)		(x) 	Test	Coin	Pbtn1	Pbtn0	Tog3	Tog2	Tog1	Tog0	LGrip	LThumb	LTrig	Rgrip	Rthumb	RTrig
 380:vec9_io.c     **** 
 381:vec9_io.c     **** 
 382:vec9_io.c     **** 
 383:vec9_io.c     **** static void HandleSwitches(void)
 384:vec9_io.c     **** // Read input pins, debounce, and flag newly-appeared keys.
 385:vec9_io.c     **** // NOTE -- because the inputs have been inverted, they are already positive true
 386:vec9_io.c     **** // NOTE -- For PORTB to work right, JTAG must be disabed.
 387:vec9_io.c     **** {
 388:vec9_io.c     **** 	static unsigned int
 389:vec9_io.c     **** 		lastKeyState;
 390:vec9_io.c     **** 	unsigned int
 391:vec9_io.c     **** 		temp;
 392:vec9_io.c     **** 
 393:vec9_io.c     **** 	lastKeyState=keyState;					// Record old keystate for comparison's sake
 394:vec9_io.c     **** 
 395:vec9_io.c     **** 	if(CheckTimer(TIMER_DEBOUNCE))
 396:vec9_io.c     **** 	{
 397:vec9_io.c     **** 		temp=0;
 398:vec9_io.c     **** 		temp=(PORTA.IN>>5)&0x07;				// Right hand buttons to position
 399:vec9_io.c     **** 
 400:vec9_io.c     **** 		temp|=((unsigned int)PORTB.IN)<<3;		// Grab all of PORTB (test switch will be in wrong spot)
 401:vec9_io.c     **** 
 402:vec9_io.c     **** 		temp|=((unsigned int)PORTC.IN&0x06)<<9;	// Get two pushbuttons.  Note, we don't scoot this over a
 403:vec9_io.c     **** 		
 404:vec9_io.c     **** 		if(PORTC.IN&(1<<0))		// Check coin switch, out of order
 405:vec9_io.c     **** 		{
 406:vec9_io.c     **** 			temp|=Im_COIN;
 407:vec9_io.c     **** 		}
 408:vec9_io.c     **** 		if(PORTB.IN&(1<<7))		// Check test switch, out of order
 409:vec9_io.c     **** 		{
 410:vec9_io.c     **** 			temp|=Im_TEST;
 411:vec9_io.c     **** 		}
 412:vec9_io.c     **** 			
 413:vec9_io.c     **** 		keyState=temp;
 414:vec9_io.c     **** 
 415:vec9_io.c     **** //		keyState=PORTB.IN;								// Grab all PORTB inputs
 416:vec9_io.c     **** //		keyState|=((unsigned int)PORTC.IN&0x1F)<<8;		// Grab bottom 5 PORTC
 417:vec9_io.c     **** 
 418:vec9_io.c     **** //		if(PORTE.IN&(1<<2))		// Check test switch, alone on this port
 419:vec9_io.c     **** //		{
 420:vec9_io.c     **** //			keyState|=Im_TEST;
 421:vec9_io.c     **** //		}
 422:vec9_io.c     **** 
 423:vec9_io.c     **** 		SetTimer(TIMER_DEBOUNCE,(SECOND/64));
 424:vec9_io.c     **** 	}
 425:vec9_io.c     **** 
 426:vec9_io.c     **** 	newKeys=((keyState^lastKeyState)&(keyState));			// Flag the keys which have been pressed since the
 427:vec9_io.c     **** 	newKeysReleased=lastKeyState&(keyState^lastKeyState);	// And the ones immediately un-pressed
 428:vec9_io.c     **** }
 429:vec9_io.c     **** 
 430:vec9_io.c     **** //-----------------------------------------------------------------------
 431:vec9_io.c     **** //-----------------------------------------------------------------------
 432:vec9_io.c     **** // ADC Handling:
 433:vec9_io.c     **** //-----------------------------------------------------------------------
 434:vec9_io.c     **** //-----------------------------------------------------------------------
 435:vec9_io.c     **** // ADC has serious errata in this device -- see DS.
 436:vec9_io.c     **** // We must used the signed mode (even though we are single ended) and our VREF is external and set 
 437:vec9_io.c     **** // This means that we have 11 bit accuracy and not 12, and there are some other weirdnesses too.
 438:vec9_io.c     **** // For instance, since we are running differential, it is helpful to tie a PORT pin to ground and u
 439:vec9_io.c     **** 
 440:vec9_io.c     **** // Some helpful posts:
 441:vec9_io.c     **** // http://blog.frankvh.com/2010/01/03/atmel-xmega-adc-problems-solutions/
 442:vec9_io.c     **** // http://www.bostonandroid.com/manuals/xmega-precision-adc-howto.html
 443:vec9_io.c     **** 
 444:vec9_io.c     **** // Thu Nov 17 15:06:04 EST 2011
 445:vec9_io.c     **** // As far as I can tell, a single conversion without gain takes 6 adc clock cycles
 446:vec9_io.c     **** // So, at 125hKz adc clock, throwing out 4 samples and averaging 32, each source we read takes abou
 447:vec9_io.c     **** 
 448:vec9_io.c     **** // NOTE -- decent stability at /64
 449:vec9_io.c     **** 
 450:vec9_io.c     **** // Sat Feb  2 16:34:39 EST 2013
 451:vec9_io.c     **** // Switched to -AU series xmegas.  In theory these fix all the old ADC problems.  We'll see...
 452:vec9_io.c     **** // Sample time is 7 adc clock cycles.  So at 20MHz / 512 (39kHz) we have 0.18mSec per sample.
 453:vec9_io.c     **** // At 36 samples per source, we have 6.5mSec per source
 454:vec9_io.c     **** // With 5 sources we'd have 32mSec to get everything (or 31Hz update rate).
 455:vec9_io.c     **** // 2 sources is 77 times a second.
 456:vec9_io.c     **** 
 457:vec9_io.c     **** #define		SAMPLES_TO_ADD		8		// Don't exceed an int adding these up
 458:vec9_io.c     **** #define		SAMPLES_TO_AVERAGE	8		// Then divide by this.  Can get oversampling if needed.
 459:vec9_io.c     **** #define		SAMPLES_TO_TOSS		4		// Throw out this many every time we change the mux
 460:vec9_io.c     **** 
 461:vec9_io.c     **** enum									// Things our ADC is keeping track of
 462:vec9_io.c     **** 	{
 463:vec9_io.c     **** 		ADC_YOKE_PITCH=0,
 464:vec9_io.c     **** 		ADC_YOKE_ROLL,
 465:vec9_io.c     **** 		NUM_ADC,
 466:vec9_io.c     **** 	};
 467:vec9_io.c     **** 
 468:vec9_io.c     **** static unsigned int
 469:vec9_io.c     **** 	adcResults[NUM_ADC];	// Store processed results here
 470:vec9_io.c     **** static bool
 471:vec9_io.c     **** 	newAdcResult[NUM_ADC];	// Flags which tell when an ADC result is new
 472:vec9_io.c     **** static unsigned char
 473:vec9_io.c     **** 	currentAdcSource;			// Which ADC input are we looking at?
 474:vec9_io.c     **** 
 475:vec9_io.c     **** static unsigned long
 476:vec9_io.c     **** 	adcResultTemp;			// Accumulator for averaging/oversampling
 477:vec9_io.c     **** static unsigned char
 478:vec9_io.c     **** 	adcSampleCount;			// How many samples have we pulled in for this particular measurement?
 479:vec9_io.c     **** 
 480:vec9_io.c     **** static void InitAdc(void)
 481:vec9_io.c     **** // For ADCA.
 482:vec9_io.c     **** {
 483:vec9_io.c     **** 	unsigned char
 484:vec9_io.c     **** 		i;
 485:vec9_io.c     **** 
 486:vec9_io.c     **** 	// Init ADC hardware:
 487:vec9_io.c     **** 
 488:vec9_io.c     **** 	PR.PRPA&=~PR_ADC_bm;									// Make sure ADC is on
 489:vec9_io.c     **** 	PORTA.DIRCLR=0x0F;										// PORTA analog inputs to inputs
 490:vec9_io.c     **** 
 491:vec9_io.c     **** //	ADCA.CTRLB=ADC_CONVMODE_bm|ADC_RESOLUTION_12BIT_gc;		// Set signed mode, 12 bit right justified,
 492:vec9_io.c     **** 	ADCA.CTRLB=0x10;										// Same as above, no "convmode" bitmask
 493:vec9_io.c     **** 	ADCA.REFCTRL=ADC_REFSEL_AREFA_gc;						// External reference A, bandgap and temp disabled
 494:vec9_io.c     **** //	ADCA.PRESCALER=ADC_PRESCALER_DIV256_gc;					// 16MHz divided by 256 = 62.5kHz  (see notes)	-- OG
 495:vec9_io.c     **** //	ADCA.PRESCALER=ADC_PRESCALER_DIV128_gc;					// 16MHz divided by 128 = 125kHz  (see notes)	-- thi
 496:vec9_io.c     **** 	ADCA.PRESCALER=ADC_PRESCALER_DIV512_gc;					// See notes	-- real slow for high impedance
 497:vec9_io.c     **** 
 498:vec9_io.c     **** 	ADCA.CH0.CTRL=ADC_CH_INPUTMODE_DIFF_gc;							// Differential input, no gain.
 499:vec9_io.c     **** 	ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN2_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN2 (PA2), Neg
 500:vec9_io.c     **** 	ADCA.CH0.INTCTRL=0;												// No interrupts
 501:vec9_io.c     **** 
 502:vec9_io.c     **** 	ADCA.CTRLA=ADC_ENABLE_bm;								// Enable the ADC
 503:vec9_io.c     **** 
 504:vec9_io.c     **** 	// Init our application ADC variables:
 505:vec9_io.c     **** 
 506:vec9_io.c     **** 	adcResultTemp=0;	// Zero our accumulator
 507:vec9_io.c     **** 	adcSampleCount=0;	// Zero oversample/average counter
 508:vec9_io.c     **** 
 509:vec9_io.c     **** 	for(i=0;i<NUM_ADC;i++)	// Zero results
 510:vec9_io.c     **** 	{
 511:vec9_io.c     **** 		adcResults[i]=0;
 512:vec9_io.c     **** 		newAdcResult[i]=false;
 513:vec9_io.c     **** 	}
 514:vec9_io.c     **** 
 515:vec9_io.c     **** 	currentAdcSource=0;	// Look at the first signal source
 516:vec9_io.c     **** 
 517:vec9_io.c     **** 	ADCA.CH0.CTRL|=ADC_CH_START_bm; 	// Start conversion on channel 0
 518:vec9_io.c     **** 
 519:vec9_io.c     **** }
 520:vec9_io.c     **** 
 521:vec9_io.c     **** static void UpdateAdc(void)
 522:vec9_io.c     **** // Scan through positioner, pressure, get the results and put them in their respective result regis
 523:vec9_io.c     **** // Motor current monitor is done on its own time (should go fast, doesn't need accuracy)
 524:vec9_io.c     **** {
 525:vec9_io.c     **** 	unsigned char
 526:vec9_io.c     **** 		i;
 527:vec9_io.c     **** 	int
 528:vec9_io.c     **** 		temp;
 529:vec9_io.c     **** 	static unsigned char
 530:vec9_io.c     **** 		tossCounter=SAMPLES_TO_TOSS;
 531:vec9_io.c     **** 
 532:vec9_io.c     **** 	for(i=0;i<NUM_ADC;i++)		// New results only stay new for a loop
 533:vec9_io.c     **** 	{
 534:vec9_io.c     **** 		newAdcResult[i]=false;
 535:vec9_io.c     **** 	}
 536:vec9_io.c     **** 
 537:vec9_io.c     **** 	if(ADCA.CH0.INTFLAGS&ADC_CH0IF_bm)	// Got a complete conversion on CH0?
 538:vec9_io.c     **** 	{
 539:vec9_io.c     **** 		temp=ADCA.CH0RES;			// Get result
 540:vec9_io.c     **** 
 541:vec9_io.c     **** 		if(tossCounter)				// Throw out a couple results while we let mux settle (may not be necessary, b
 542:vec9_io.c     **** 		{
 543:vec9_io.c     **** 			tossCounter--;
 544:vec9_io.c     **** 		}
 545:vec9_io.c     **** 		else
 546:vec9_io.c     **** 		{
 547:vec9_io.c     **** 			if(temp<0)					// Pin results positive
 548:vec9_io.c     **** 			{
 549:vec9_io.c     **** 				temp=0;
 550:vec9_io.c     **** 			}
 551:vec9_io.c     **** 
 552:vec9_io.c     **** 			adcResultTemp+=temp;		// Add to accumulator
 553:vec9_io.c     **** 			adcSampleCount++;			// One more sample gathered
 554:vec9_io.c     **** 
 555:vec9_io.c     **** 			if(adcSampleCount>=SAMPLES_TO_ADD)	// Got enough samples?
 556:vec9_io.c     **** 			{
 557:vec9_io.c     **** 				adcResults[currentAdcSource]=(adcResultTemp/SAMPLES_TO_AVERAGE);	// export reading, with averag
 558:vec9_io.c     **** 				newAdcResult[currentAdcSource]=true;								// Let program know we have a new ADC reading
 559:vec9_io.c     **** 
 560:vec9_io.c     **** 				adcSampleCount=0;						// Restart accumulator
 561:vec9_io.c     **** 				tossCounter=SAMPLES_TO_TOSS;			// Ignore initial samples after switching the mux
 562:vec9_io.c     **** 				adcResultTemp=0;						// Clear temp register
 563:vec9_io.c     **** 
 564:vec9_io.c     **** 				currentAdcSource++;						// Get our next signal source
 565:vec9_io.c     **** 				if(currentAdcSource>=NUM_ADC)			// Roll it around
 566:vec9_io.c     **** 				{
 567:vec9_io.c     **** 					currentAdcSource=0;
 568:vec9_io.c     **** 				}
 569:vec9_io.c     **** 
 570:vec9_io.c     **** 				switch(currentAdcSource)		// Set mux to the next signal source
 571:vec9_io.c     **** 				{
 572:vec9_io.c     **** 					case ADC_YOKE_PITCH:											// PA2
 573:vec9_io.c     **** 					ADCA.CH0.CTRL=ADC_CH_INPUTMODE_DIFF_gc;							// Differential input, no gain.
 574:vec9_io.c     **** 					ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN2_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN2 (PA2),
 575:vec9_io.c     **** 					break;
 576:vec9_io.c     **** 
 577:vec9_io.c     **** 					case ADC_YOKE_ROLL:												// PA1
 578:vec9_io.c     **** 					ADCA.CH0.CTRL=ADC_CH_INPUTMODE_DIFF_gc;							// Differential input, no gain.
 579:vec9_io.c     **** 					ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN1_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN1 (PA1),
 580:vec9_io.c     **** 					break;
 581:vec9_io.c     **** 
 582:vec9_io.c     **** 					default:
 583:vec9_io.c     **** 					// should probably either wdr or at least reset ADC
 584:vec9_io.c     **** 					// *** Bad execution ***
 585:vec9_io.c     **** 					break;
 586:vec9_io.c     **** 				}
 587:vec9_io.c     **** 			}
 588:vec9_io.c     **** 
 589:vec9_io.c     **** 			ADCA.CH0.INTFLAGS|=ADC_CH0IF_bm;	// Clear flag
 590:vec9_io.c     **** 			ADCA.CH0.CTRL|=ADC_CH_START_bm; 	// Start conversion on channel 0
 591:vec9_io.c     **** 		}
 592:vec9_io.c     **** 	}
 593:vec9_io.c     **** }
 594:vec9_io.c     **** 
 595:vec9_io.c     **** 
 596:vec9_io.c     **** //-----------------------------------------------------------------------
 597:vec9_io.c     **** //-----------------------------------------------------------------------
 598:vec9_io.c     **** // Output Handling
 599:vec9_io.c     **** //-----------------------------------------------------------------------
 600:vec9_io.c     **** //-----------------------------------------------------------------------
 601:vec9_io.c     **** 
 602:vec9_io.c     **** // The three bytes that the host sends us are defined in defines.h
 603:vec9_io.c     **** 
 604:vec9_io.c     **** static unsigned char
 605:vec9_io.c     **** 	outputByteHigh=0,
 606:vec9_io.c     **** 	outputByteMiddle=0,
 607:vec9_io.c     **** 	outputByteLow=0;
 608:vec9_io.c     **** 
 609:vec9_io.c     **** static void InitOutputs(void)
 610:vec9_io.c     **** // Turn all output pins to drivers and set them low except damage LEDs, set them high.
 611:vec9_io.c     **** {	
 612:vec9_io.c     **** 	PORTC.OUTCLR=0x38;		// Bits 3, 4, 5
 613:vec9_io.c     **** 	PORTC.DIRSET=0x38;		
 614:vec9_io.c     **** 
 615:vec9_io.c     **** 	PORTD.OUTSET=0xFF;		// Everything off (LEDs, bits inverted)	
 616:vec9_io.c     **** 	PORTD.DIRSET=0xFF;		
 617:vec9_io.c     **** 
 618:vec9_io.c     **** 	PORTE.OUTCLR=0xFF;		// Everything off (lamps, not inverted)
 619:vec9_io.c     **** 	PORTE.DIRSET=0xFF;		
 620:vec9_io.c     **** 
 621:vec9_io.c     **** 	PORTF.OUTCLR=0x03;		// Bits 0, 1
 622:vec9_io.c     **** 	PORTF.DIRSET=0x03;		
 623:vec9_io.c     **** }
 624:vec9_io.c     **** 
 625:vec9_io.c     **** static void SetOutputs(void)
 626:vec9_io.c     **** // Sets output bits based on what we got from the host.
 627:vec9_io.c     **** {
 103               		.loc 1 627 0
 104               		.cfi_startproc
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 0 */
 108               	.L__stack_usage = 0
 628:vec9_io.c     **** 	// High byte (Flight indicators)
 629:vec9_io.c     **** 	// -----------------------------------------
 630:vec9_io.c     **** 	if(outputByteHigh&Om_FLIGHT_IND_0)
 109               		.loc 1 630 0
 110 003a 8091 0000 		lds r24,outputByteHigh
 631:vec9_io.c     **** 	{
 632:vec9_io.c     **** 		PORTE.OUTSET=(1<<0);
 111               		.loc 1 632 0
 112 003e 91E0      		ldi r25,lo8(1)
 630:vec9_io.c     **** 	{
 113               		.loc 1 630 0
 114 0040 84FF      		sbrs r24,4
 115 0042 00C0      		rjmp .L9
 116               		.loc 1 632 0
 117 0044 9093 8506 		sts 1669,r25
 118 0048 00C0      		rjmp .L10
 119               	.L9:
 633:vec9_io.c     **** 	}
 634:vec9_io.c     **** 	else
 635:vec9_io.c     **** 	{
 636:vec9_io.c     **** 		PORTE.OUTCLR=(1<<0);	
 120               		.loc 1 636 0
 121 004a 9093 8606 		sts 1670,r25
 122               	.L10:
 637:vec9_io.c     **** 	}
 638:vec9_io.c     **** 	if(outputByteHigh&Om_FLIGHT_IND_1)
 639:vec9_io.c     **** 	{
 640:vec9_io.c     **** 		PORTE.OUTSET=(1<<1);
 123               		.loc 1 640 0
 124 004e 92E0      		ldi r25,lo8(2)
 638:vec9_io.c     **** 	{
 125               		.loc 1 638 0
 126 0050 83FF      		sbrs r24,3
 127 0052 00C0      		rjmp .L11
 128               		.loc 1 640 0
 129 0054 9093 8506 		sts 1669,r25
 130 0058 00C0      		rjmp .L12
 131               	.L11:
 641:vec9_io.c     **** 	}
 642:vec9_io.c     **** 	else
 643:vec9_io.c     **** 	{
 644:vec9_io.c     **** 		PORTE.OUTCLR=(1<<1);	
 132               		.loc 1 644 0
 133 005a 9093 8606 		sts 1670,r25
 134               	.L12:
 645:vec9_io.c     **** 	}
 646:vec9_io.c     **** 	if(outputByteHigh&Om_FLIGHT_IND_2)
 647:vec9_io.c     **** 	{
 648:vec9_io.c     **** 		PORTE.OUTSET=(1<<2);
 135               		.loc 1 648 0
 136 005e 94E0      		ldi r25,lo8(4)
 646:vec9_io.c     **** 	{
 137               		.loc 1 646 0
 138 0060 82FF      		sbrs r24,2
 139 0062 00C0      		rjmp .L13
 140               		.loc 1 648 0
 141 0064 9093 8506 		sts 1669,r25
 142 0068 00C0      		rjmp .L14
 143               	.L13:
 649:vec9_io.c     **** 	}
 650:vec9_io.c     **** 	else
 651:vec9_io.c     **** 	{
 652:vec9_io.c     **** 		PORTE.OUTCLR=(1<<2);	
 144               		.loc 1 652 0
 145 006a 9093 8606 		sts 1670,r25
 146               	.L14:
 653:vec9_io.c     **** 	}
 654:vec9_io.c     **** 
 655:vec9_io.c     **** 	if(outputByteHigh&Om_FLIGHT_IND_3)
 656:vec9_io.c     **** 	{
 657:vec9_io.c     **** 		PORTE.OUTSET=(1<<3);
 147               		.loc 1 657 0
 148 006e 98E0      		ldi r25,lo8(8)
 655:vec9_io.c     **** 	{
 149               		.loc 1 655 0
 150 0070 81FF      		sbrs r24,1
 151 0072 00C0      		rjmp .L15
 152               		.loc 1 657 0
 153 0074 9093 8506 		sts 1669,r25
 154 0078 00C0      		rjmp .L16
 155               	.L15:
 658:vec9_io.c     **** 	}
 659:vec9_io.c     **** 	else
 660:vec9_io.c     **** 	{
 661:vec9_io.c     **** 		PORTE.OUTCLR=(1<<3);	
 156               		.loc 1 661 0
 157 007a 9093 8606 		sts 1670,r25
 158               	.L16:
 662:vec9_io.c     **** 	}
 663:vec9_io.c     **** 	if(outputByteHigh&Om_FLIGHT_IND_4)
 159               		.loc 1 663 0
 160 007e 80FF      		sbrs r24,0
 161 0080 00C0      		rjmp .L17
 664:vec9_io.c     **** 	{
 665:vec9_io.c     **** 		PORTE.OUTSET=(1<<4);
 162               		.loc 1 665 0
 163 0082 80E1      		ldi r24,lo8(16)
 164 0084 8093 8506 		sts 1669,r24
 165 0088 00C0      		rjmp .L18
 166               	.L17:
 666:vec9_io.c     **** 	}
 667:vec9_io.c     **** 	else
 668:vec9_io.c     **** 	{
 669:vec9_io.c     **** 		PORTE.OUTCLR=(1<<4);	
 167               		.loc 1 669 0
 168 008a 80E1      		ldi r24,lo8(16)
 169 008c 8093 8606 		sts 1670,r24
 170               	.L18:
 670:vec9_io.c     **** 	}
 671:vec9_io.c     **** 
 672:vec9_io.c     **** 	// Middle Byte (Flight ind, horn, PB lamps)
 673:vec9_io.c     **** 	// ---------------------------------------------
 674:vec9_io.c     **** 
 675:vec9_io.c     **** 	if(outputByteMiddle&Om_FLIGHT_IND_5)
 171               		.loc 1 675 0
 172 0090 8091 0000 		lds r24,outputByteMiddle
 676:vec9_io.c     **** 	{
 677:vec9_io.c     **** 		PORTE.OUTSET=(1<<5);
 173               		.loc 1 677 0
 174 0094 90E2      		ldi r25,lo8(32)
 675:vec9_io.c     **** 	{
 175               		.loc 1 675 0
 176 0096 87FF      		sbrs r24,7
 177 0098 00C0      		rjmp .L19
 178               		.loc 1 677 0
 179 009a 9093 8506 		sts 1669,r25
 180 009e 00C0      		rjmp .L20
 181               	.L19:
 678:vec9_io.c     **** 	}
 679:vec9_io.c     **** 	else
 680:vec9_io.c     **** 	{
 681:vec9_io.c     **** 		PORTE.OUTCLR=(1<<5);	
 182               		.loc 1 681 0
 183 00a0 9093 8606 		sts 1670,r25
 184               	.L20:
 682:vec9_io.c     **** 	}
 683:vec9_io.c     **** 	if(outputByteMiddle&Om_FLIGHT_IND_6)
 684:vec9_io.c     **** 	{
 685:vec9_io.c     **** 		PORTE.OUTSET=(1<<6);
 185               		.loc 1 685 0
 186 00a4 90E4      		ldi r25,lo8(64)
 683:vec9_io.c     **** 	{
 187               		.loc 1 683 0
 188 00a6 86FF      		sbrs r24,6
 189 00a8 00C0      		rjmp .L21
 190               		.loc 1 685 0
 191 00aa 9093 8506 		sts 1669,r25
 192 00ae 00C0      		rjmp .L22
 193               	.L21:
 686:vec9_io.c     **** 	}
 687:vec9_io.c     **** 	else
 688:vec9_io.c     **** 	{
 689:vec9_io.c     **** 		PORTE.OUTCLR=(1<<6);	
 194               		.loc 1 689 0
 195 00b0 9093 8606 		sts 1670,r25
 196               	.L22:
 690:vec9_io.c     **** 	}
 691:vec9_io.c     **** 	if(outputByteMiddle&Om_FLIGHT_IND_7)
 692:vec9_io.c     **** 	{
 693:vec9_io.c     **** 		PORTE.OUTSET=(1<<7);
 197               		.loc 1 693 0
 198 00b4 90E8      		ldi r25,lo8(-128)
 691:vec9_io.c     **** 	{
 199               		.loc 1 691 0
 200 00b6 85FF      		sbrs r24,5
 201 00b8 00C0      		rjmp .L23
 202               		.loc 1 693 0
 203 00ba 9093 8506 		sts 1669,r25
 204 00be 00C0      		rjmp .L24
 205               	.L23:
 694:vec9_io.c     **** 	}
 695:vec9_io.c     **** 	else
 696:vec9_io.c     **** 	{
 697:vec9_io.c     **** 		PORTE.OUTCLR=(1<<7);	
 206               		.loc 1 697 0
 207 00c0 9093 8606 		sts 1670,r25
 208               	.L24:
 698:vec9_io.c     **** 	}
 699:vec9_io.c     **** 	if(outputByteMiddle&Om_FLIGHT_IND_8)
 700:vec9_io.c     **** 	{
 701:vec9_io.c     **** 		PORTF.OUTSET=(1<<0);
 209               		.loc 1 701 0
 210 00c4 91E0      		ldi r25,lo8(1)
 699:vec9_io.c     **** 	{
 211               		.loc 1 699 0
 212 00c6 84FF      		sbrs r24,4
 213 00c8 00C0      		rjmp .L25
 214               		.loc 1 701 0
 215 00ca 9093 A506 		sts 1701,r25
 216 00ce 00C0      		rjmp .L26
 217               	.L25:
 702:vec9_io.c     **** 	}
 703:vec9_io.c     **** 	else
 704:vec9_io.c     **** 	{
 705:vec9_io.c     **** 		PORTF.OUTCLR=(1<<0);	
 218               		.loc 1 705 0
 219 00d0 9093 A606 		sts 1702,r25
 220               	.L26:
 706:vec9_io.c     **** 	}
 707:vec9_io.c     **** 	if(outputByteMiddle&Om_FLIGHT_IND_9)
 708:vec9_io.c     **** 	{
 709:vec9_io.c     **** 		PORTF.OUTSET=(1<<1);
 221               		.loc 1 709 0
 222 00d4 92E0      		ldi r25,lo8(2)
 707:vec9_io.c     **** 	{
 223               		.loc 1 707 0
 224 00d6 83FF      		sbrs r24,3
 225 00d8 00C0      		rjmp .L27
 226               		.loc 1 709 0
 227 00da 9093 A506 		sts 1701,r25
 228 00de 00C0      		rjmp .L28
 229               	.L27:
 710:vec9_io.c     **** 	}
 711:vec9_io.c     **** 	else
 712:vec9_io.c     **** 	{
 713:vec9_io.c     **** 		PORTF.OUTCLR=(1<<1);	
 230               		.loc 1 713 0
 231 00e0 9093 A606 		sts 1702,r25
 232               	.L28:
 714:vec9_io.c     **** 	}
 715:vec9_io.c     **** 	if(outputByteMiddle&Om_AIR_HORN)
 716:vec9_io.c     **** 	{
 717:vec9_io.c     **** 		PORTC.OUTSET=(1<<5);
 233               		.loc 1 717 0
 234 00e4 90E2      		ldi r25,lo8(32)
 715:vec9_io.c     **** 	{
 235               		.loc 1 715 0
 236 00e6 82FF      		sbrs r24,2
 237 00e8 00C0      		rjmp .L29
 238               		.loc 1 717 0
 239 00ea 9093 4506 		sts 1605,r25
 240 00ee 00C0      		rjmp .L30
 241               	.L29:
 718:vec9_io.c     **** 	}
 719:vec9_io.c     **** 	else
 720:vec9_io.c     **** 	{
 721:vec9_io.c     **** 		PORTC.OUTCLR=(1<<5);	
 242               		.loc 1 721 0
 243 00f0 9093 4606 		sts 1606,r25
 244               	.L30:
 722:vec9_io.c     **** 	}
 723:vec9_io.c     **** 	if(outputByteMiddle&Om_PUSHBUTTON_LAMP_0)
 724:vec9_io.c     **** 	{
 725:vec9_io.c     **** 		PORTC.OUTSET=(1<<3);
 245               		.loc 1 725 0
 246 00f4 98E0      		ldi r25,lo8(8)
 723:vec9_io.c     **** 	{
 247               		.loc 1 723 0
 248 00f6 81FF      		sbrs r24,1
 249 00f8 00C0      		rjmp .L31
 250               		.loc 1 725 0
 251 00fa 9093 4506 		sts 1605,r25
 252 00fe 00C0      		rjmp .L32
 253               	.L31:
 726:vec9_io.c     **** 	}
 727:vec9_io.c     **** 	else
 728:vec9_io.c     **** 	{
 729:vec9_io.c     **** 		PORTC.OUTCLR=(1<<3);	
 254               		.loc 1 729 0
 255 0100 9093 4606 		sts 1606,r25
 256               	.L32:
 730:vec9_io.c     **** 	}
 731:vec9_io.c     **** 	if(outputByteMiddle&Om_PUSHBUTTON_LAMP_1)
 257               		.loc 1 731 0
 258 0104 80FF      		sbrs r24,0
 259 0106 00C0      		rjmp .L33
 732:vec9_io.c     **** 	{
 733:vec9_io.c     **** 		PORTC.OUTSET=(1<<4);
 260               		.loc 1 733 0
 261 0108 80E1      		ldi r24,lo8(16)
 262 010a 8093 4506 		sts 1605,r24
 263 010e 00C0      		rjmp .L34
 264               	.L33:
 734:vec9_io.c     **** 	}
 735:vec9_io.c     **** 	else
 736:vec9_io.c     **** 	{
 737:vec9_io.c     **** 		PORTC.OUTCLR=(1<<4);	
 265               		.loc 1 737 0
 266 0110 80E1      		ldi r24,lo8(16)
 267 0112 8093 4606 		sts 1606,r24
 268               	.L34:
 738:vec9_io.c     **** 	}
 739:vec9_io.c     **** 
 740:vec9_io.c     **** 	// Low Byte (Damage / Code LEDs)
 741:vec9_io.c     **** 	// Note -- invert these (hex inverts buffer AVR's outputs)
 742:vec9_io.c     **** 	// --------------------------------------------------------
 743:vec9_io.c     **** 
 744:vec9_io.c     **** 	if(outputByteLow&Om_GREEN_LED_0)
 269               		.loc 1 744 0
 270 0116 8091 0000 		lds r24,outputByteLow
 745:vec9_io.c     **** 	{
 746:vec9_io.c     **** 		PORTD.OUTCLR=(1<<4);
 271               		.loc 1 746 0
 272 011a 90E1      		ldi r25,lo8(16)
 744:vec9_io.c     **** 	{
 273               		.loc 1 744 0
 274 011c 87FF      		sbrs r24,7
 275 011e 00C0      		rjmp .L35
 276               		.loc 1 746 0
 277 0120 9093 6606 		sts 1638,r25
 278 0124 00C0      		rjmp .L36
 279               	.L35:
 747:vec9_io.c     **** 	}
 748:vec9_io.c     **** 	else
 749:vec9_io.c     **** 	{
 750:vec9_io.c     **** 		PORTD.OUTSET=(1<<4);	
 280               		.loc 1 750 0
 281 0126 9093 6506 		sts 1637,r25
 282               	.L36:
 751:vec9_io.c     **** 	}
 752:vec9_io.c     **** 	if(outputByteLow&Om_GREEN_LED_1)
 753:vec9_io.c     **** 	{
 754:vec9_io.c     **** 		PORTD.OUTCLR=(1<<5);
 283               		.loc 1 754 0
 284 012a 90E2      		ldi r25,lo8(32)
 752:vec9_io.c     **** 	{
 285               		.loc 1 752 0
 286 012c 86FF      		sbrs r24,6
 287 012e 00C0      		rjmp .L37
 288               		.loc 1 754 0
 289 0130 9093 6606 		sts 1638,r25
 290 0134 00C0      		rjmp .L38
 291               	.L37:
 755:vec9_io.c     **** 	}
 756:vec9_io.c     **** 	else
 757:vec9_io.c     **** 	{
 758:vec9_io.c     **** 		PORTD.OUTSET=(1<<5);	
 292               		.loc 1 758 0
 293 0136 9093 6506 		sts 1637,r25
 294               	.L38:
 759:vec9_io.c     **** 	}
 760:vec9_io.c     **** 	if(outputByteLow&Om_GREEN_LED_2)
 761:vec9_io.c     **** 	{
 762:vec9_io.c     **** 		PORTD.OUTCLR=(1<<6);
 295               		.loc 1 762 0
 296 013a 90E4      		ldi r25,lo8(64)
 760:vec9_io.c     **** 	{
 297               		.loc 1 760 0
 298 013c 85FF      		sbrs r24,5
 299 013e 00C0      		rjmp .L39
 300               		.loc 1 762 0
 301 0140 9093 6606 		sts 1638,r25
 302 0144 00C0      		rjmp .L40
 303               	.L39:
 763:vec9_io.c     **** 	}
 764:vec9_io.c     **** 	else
 765:vec9_io.c     **** 	{
 766:vec9_io.c     **** 		PORTD.OUTSET=(1<<6);	
 304               		.loc 1 766 0
 305 0146 9093 6506 		sts 1637,r25
 306               	.L40:
 767:vec9_io.c     **** 	}
 768:vec9_io.c     **** 	if(outputByteLow&Om_GREEN_LED_3)
 769:vec9_io.c     **** 	{
 770:vec9_io.c     **** 		PORTD.OUTCLR=(1<<7);
 307               		.loc 1 770 0
 308 014a 90E8      		ldi r25,lo8(-128)
 768:vec9_io.c     **** 	{
 309               		.loc 1 768 0
 310 014c 84FF      		sbrs r24,4
 311 014e 00C0      		rjmp .L41
 312               		.loc 1 770 0
 313 0150 9093 6606 		sts 1638,r25
 314 0154 00C0      		rjmp .L42
 315               	.L41:
 771:vec9_io.c     **** 	}
 772:vec9_io.c     **** 	else
 773:vec9_io.c     **** 	{
 774:vec9_io.c     **** 		PORTD.OUTSET=(1<<7);	
 316               		.loc 1 774 0
 317 0156 9093 6506 		sts 1637,r25
 318               	.L42:
 775:vec9_io.c     **** 	}
 776:vec9_io.c     **** 	if(outputByteLow&Om_RED_LED_0)
 777:vec9_io.c     **** 	{
 778:vec9_io.c     **** 		PORTD.OUTCLR=(1<<0);
 319               		.loc 1 778 0
 320 015a 91E0      		ldi r25,lo8(1)
 776:vec9_io.c     **** 	{
 321               		.loc 1 776 0
 322 015c 83FF      		sbrs r24,3
 323 015e 00C0      		rjmp .L43
 324               		.loc 1 778 0
 325 0160 9093 6606 		sts 1638,r25
 326 0164 00C0      		rjmp .L44
 327               	.L43:
 779:vec9_io.c     **** 	}
 780:vec9_io.c     **** 	else
 781:vec9_io.c     **** 	{
 782:vec9_io.c     **** 		PORTD.OUTSET=(1<<0);	
 328               		.loc 1 782 0
 329 0166 9093 6506 		sts 1637,r25
 330               	.L44:
 783:vec9_io.c     **** 	}
 784:vec9_io.c     **** 	if(outputByteLow&Om_RED_LED_1)
 785:vec9_io.c     **** 	{
 786:vec9_io.c     **** 		PORTD.OUTCLR=(1<<1);
 331               		.loc 1 786 0
 332 016a 92E0      		ldi r25,lo8(2)
 784:vec9_io.c     **** 	{
 333               		.loc 1 784 0
 334 016c 82FF      		sbrs r24,2
 335 016e 00C0      		rjmp .L45
 336               		.loc 1 786 0
 337 0170 9093 6606 		sts 1638,r25
 338 0174 00C0      		rjmp .L46
 339               	.L45:
 787:vec9_io.c     **** 	}
 788:vec9_io.c     **** 	else
 789:vec9_io.c     **** 	{
 790:vec9_io.c     **** 		PORTD.OUTSET=(1<<1);	
 340               		.loc 1 790 0
 341 0176 9093 6506 		sts 1637,r25
 342               	.L46:
 791:vec9_io.c     **** 	}
 792:vec9_io.c     **** 	if(outputByteLow&Om_RED_LED_2)
 793:vec9_io.c     **** 	{
 794:vec9_io.c     **** 		PORTD.OUTCLR=(1<<2);
 343               		.loc 1 794 0
 344 017a 94E0      		ldi r25,lo8(4)
 792:vec9_io.c     **** 	{
 345               		.loc 1 792 0
 346 017c 81FF      		sbrs r24,1
 347 017e 00C0      		rjmp .L47
 348               		.loc 1 794 0
 349 0180 9093 6606 		sts 1638,r25
 350 0184 00C0      		rjmp .L48
 351               	.L47:
 795:vec9_io.c     **** 	}
 796:vec9_io.c     **** 	else
 797:vec9_io.c     **** 	{
 798:vec9_io.c     **** 		PORTD.OUTSET=(1<<2);	
 352               		.loc 1 798 0
 353 0186 9093 6506 		sts 1637,r25
 354               	.L48:
 799:vec9_io.c     **** 	}
 800:vec9_io.c     **** 	if(outputByteLow&Om_RED_LED_3)
 355               		.loc 1 800 0
 356 018a 80FF      		sbrs r24,0
 357 018c 00C0      		rjmp .L49
 801:vec9_io.c     **** 	{
 802:vec9_io.c     **** 		PORTD.OUTCLR=(1<<3);
 358               		.loc 1 802 0
 359 018e 88E0      		ldi r24,lo8(8)
 360 0190 8093 6606 		sts 1638,r24
 361 0194 0895      		ret
 362               	.L49:
 803:vec9_io.c     **** 	}
 804:vec9_io.c     **** 	else
 805:vec9_io.c     **** 	{
 806:vec9_io.c     **** 		PORTD.OUTSET=(1<<3);	
 363               		.loc 1 806 0
 364 0196 88E0      		ldi r24,lo8(8)
 365 0198 8093 6506 		sts 1637,r24
 366 019c 0895      		ret
 367               		.cfi_endproc
 368               	.LFE17:
 371               	DoStartupTest:
 372               	.LFB22:
 807:vec9_io.c     **** 	}
 808:vec9_io.c     **** }
 809:vec9_io.c     **** 
 810:vec9_io.c     **** //-----------------------------------------------------------------------
 811:vec9_io.c     **** //-----------------------------------------------------------------------
 812:vec9_io.c     **** // Serial
 813:vec9_io.c     **** //-----------------------------------------------------------------------
 814:vec9_io.c     **** //-----------------------------------------------------------------------
 815:vec9_io.c     **** 
 816:vec9_io.c     **** #define		INCOMING_MESSAGE_TIMEOUT			(SECOND/8)
 817:vec9_io.c     **** 
 818:vec9_io.c     **** static unsigned char
 819:vec9_io.c     **** 	analogRoll,
 820:vec9_io.c     **** 	analogPitch;
 821:vec9_io.c     **** 
 822:vec9_io.c     **** ISR(PORTD_INT0_vect)	
 823:vec9_io.c     **** {
 824:vec9_io.c     **** }
 825:vec9_io.c     **** 
 826:vec9_io.c     **** static void UpdateIncomingSerial(void)
 827:vec9_io.c     **** // Inhales incoming serial from the PC and puts it out to the program when the entire message comes
 828:vec9_io.c     **** {
 829:vec9_io.c     **** 	unsigned char
 830:vec9_io.c     **** 		byte;
 831:vec9_io.c     **** 
 832:vec9_io.c     **** 	static unsigned char
 833:vec9_io.c     **** 		rxMessageState;
 834:vec9_io.c     **** 	bool
 835:vec9_io.c     **** 		gotMessage;
 836:vec9_io.c     **** 	
 837:vec9_io.c     **** 	gotMessage=false;	// No complete message yet
 838:vec9_io.c     **** 
 839:vec9_io.c     **** 	if(CheckTimer(TIMER_INCOMING_MESSAGE_TIMEOUT))		// If we don't get a byte for some period of time,
 840:vec9_io.c     **** 	{
 841:vec9_io.c     **** 		rxMessageState=0;
 842:vec9_io.c     **** 	}
 843:vec9_io.c     **** 	
 844:vec9_io.c     **** 	while((RxFifoNotEmpty())&&(gotMessage==false))	// Loop here handling bytes we've gotten from the c
 845:vec9_io.c     **** 	{
 846:vec9_io.c     **** 		SetTimer(TIMER_INCOMING_MESSAGE_TIMEOUT,INCOMING_MESSAGE_TIMEOUT);	// Got new bytes in the fifo, 
 847:vec9_io.c     **** 		byte=GetByteFromRxFifo();											// Inhale it
 848:vec9_io.c     **** 		switch(rxMessageState)
 849:vec9_io.c     **** 		{
 850:vec9_io.c     **** 			case 0:
 851:vec9_io.c     **** 				if(byte==0x42)			// Correct poll byte
 852:vec9_io.c     **** 				{
 853:vec9_io.c     **** 					rxMessageState=1;
 854:vec9_io.c     **** 				}
 855:vec9_io.c     **** 				break;
 856:vec9_io.c     **** 			case 1:
 857:vec9_io.c     **** 				outputByteHigh=byte;
 858:vec9_io.c     **** 				rxMessageState=2;
 859:vec9_io.c     **** 				break;
 860:vec9_io.c     **** 			case 2:
 861:vec9_io.c     **** 				outputByteMiddle=byte;
 862:vec9_io.c     **** 				rxMessageState=3;
 863:vec9_io.c     **** 				break;
 864:vec9_io.c     **** 			case 3:
 865:vec9_io.c     **** 				outputByteLow=byte;
 866:vec9_io.c     **** 				rxMessageState=0;
 867:vec9_io.c     **** 				gotMessage=true;
 868:vec9_io.c     **** 				break;
 869:vec9_io.c     **** 		}
 870:vec9_io.c     **** 	}
 871:vec9_io.c     **** 
 872:vec9_io.c     **** 	if(gotMessage)
 873:vec9_io.c     **** //	if(CheckTimer(TIMER_1))
 874:vec9_io.c     **** 	{
 875:vec9_io.c     **** 		SetOutputs();
 876:vec9_io.c     **** 
 877:vec9_io.c     **** 		// Now send out our reply
 878:vec9_io.c     **** 
 879:vec9_io.c     **** 		if(txBytesToSend==0)				// Are we done sending the last message to the host?
 880:vec9_io.c     **** 		{
 881:vec9_io.c     **** 			txBuffer[0]=0x41;
 882:vec9_io.c     **** 			txBuffer[1]=(unsigned char)((keyState>>8)&0xFF);
 883:vec9_io.c     **** 			txBuffer[2]=(unsigned char)(keyState&0xFF);
 884:vec9_io.c     **** 			txBuffer[3]=0;
 885:vec9_io.c     **** 			txBuffer[4]=0;
 886:vec9_io.c     **** 			txBuffer[5]=analogRoll;
 887:vec9_io.c     **** 			txBuffer[6]=analogPitch;
 888:vec9_io.c     **** 				
 889:vec9_io.c     **** 			txBytesToSend=7;
 890:vec9_io.c     **** 			txBufferIndex=0;
 891:vec9_io.c     **** 		}
 892:vec9_io.c     **** 
 893:vec9_io.c     **** 		//SetTimer(TIMER_1,(SECOND/8));
 894:vec9_io.c     **** 		//printf("%x %x %d %d\n",(unsigned char)((keyState>>8)&0xFF),(unsigned char)(keyState&0xFF),analo
 895:vec9_io.c     **** 	}
 896:vec9_io.c     **** }
 897:vec9_io.c     **** 
 898:vec9_io.c     **** static void UpdateOutgoingSerial(void)
 899:vec9_io.c     **** // Keep bytes going out to the host if necessary
 900:vec9_io.c     **** {
 901:vec9_io.c     **** 	if(txBytesToSend)	// Anything to go out?
 902:vec9_io.c     **** 	{
 903:vec9_io.c     **** 		if(UartTxBufferReady())		// Room in the Uart TX fifo?
 904:vec9_io.c     **** 		{
 905:vec9_io.c     **** 			UartSendByte(txBuffer[txBufferIndex++]);
 906:vec9_io.c     **** 			txBytesToSend--;
 907:vec9_io.c     **** 		}
 908:vec9_io.c     **** 	}
 909:vec9_io.c     **** }
 910:vec9_io.c     **** 
 911:vec9_io.c     **** //-----------------------------------------------------------------------
 912:vec9_io.c     **** //-----------------------------------------------------------------------
 913:vec9_io.c     **** // High Level
 914:vec9_io.c     **** //-----------------------------------------------------------------------
 915:vec9_io.c     **** //-----------------------------------------------------------------------
 916:vec9_io.c     **** 
 917:vec9_io.c     **** static void DoUpdateIo(void)
 918:vec9_io.c     **** // Keep reading the switches, and update indicators when told
 919:vec9_io.c     **** {
 920:vec9_io.c     **** 
 921:vec9_io.c     **** 	// If new ADC reading, put it in the mask
 922:vec9_io.c     **** 	if(newAdcResult[ADC_YOKE_PITCH]==true)
 923:vec9_io.c     **** 	{
 924:vec9_io.c     **** 		analogPitch=(unsigned char)(adcResults[ADC_YOKE_PITCH]/8);		// Get back to 8 bits
 925:vec9_io.c     **** 	}
 926:vec9_io.c     **** 	if(newAdcResult[ADC_YOKE_ROLL]==true)
 927:vec9_io.c     **** 	{
 928:vec9_io.c     **** 		analogRoll=(unsigned char)(adcResults[ADC_YOKE_ROLL]/8);		// Get back to 8 bits
 929:vec9_io.c     **** 	}
 930:vec9_io.c     **** 
 931:vec9_io.c     **** 	UpdateIncomingSerial();		// If we get a full message from the PC, do what it says and send a reply
 932:vec9_io.c     **** 	if(txBytesToSend)
 933:vec9_io.c     **** 	{
 934:vec9_io.c     **** 		UpdateOutgoingSerial();
 935:vec9_io.c     **** 	}
 936:vec9_io.c     **** }
 937:vec9_io.c     **** 
 938:vec9_io.c     **** #define		HORN_INTRO_TIME		(SECOND/4)
 939:vec9_io.c     **** #define		CHASE_TIME			(SECOND/8)
 940:vec9_io.c     **** #define		LAMP_TIME			((SECOND*4)/3)
 941:vec9_io.c     **** 
 942:vec9_io.c     **** 
 943:vec9_io.c     **** static void DoStartupTest(void)
 944:vec9_io.c     **** // At power on, go here and make pretty / diagnostic light chases until the game boots.
 945:vec9_io.c     **** // Leave this state when we start receiving bytes over serial.
 946:vec9_io.c     **** {
 373               		.loc 1 946 0
 374               		.cfi_startproc
 375 019e CF93      		push r28
 376               	.LCFI2:
 377               		.cfi_def_cfa_offset 3
 378               		.cfi_offset 28, -2
 379               	/* prologue: function */
 380               	/* frame size = 0 */
 381               	/* stack size = 1 */
 382               	.L__stack_usage = 1
 947:vec9_io.c     **** 	static unsigned char
 948:vec9_io.c     **** 		lastOutputByteHigh,
 949:vec9_io.c     **** 		lastOutputByteMiddle,
 950:vec9_io.c     **** 		lastOutputByteLow;
 951:vec9_io.c     **** 
 952:vec9_io.c     **** 	static unsigned char
 953:vec9_io.c     **** 		shiftIndex,
 954:vec9_io.c     **** 		lampCounter;
 955:vec9_io.c     **** 	
 956:vec9_io.c     **** 	if(subState==SS_0)					// Horn intro
 383               		.loc 1 956 0
 384 01a0 C091 0000 		lds r28,subState
 385 01a4 C111      		cpse r28,__zero_reg__
 386 01a6 00C0      		rjmp .L52
 957:vec9_io.c     **** 	{
 958:vec9_io.c     **** 		SetTimer(TIMER_1,(HORN_INTRO_TIME));
 387               		.loc 1 958 0
 388 01a8 6EEE      		ldi r22,lo8(-18)
 389 01aa 72E0      		ldi r23,lo8(2)
 390 01ac 80E0      		ldi r24,0
 391 01ae 0E94 0000 		call SetTimer
 392               	.LVL7:
 959:vec9_io.c     **** 		outputByteMiddle=Om_AIR_HORN;
 960:vec9_io.c     **** 		outputByteHigh=(Om_FLIGHT_IND_0|Om_FLIGHT_IND_1);
 393               		.loc 1 960 0
 394 01b2 88E1      		ldi r24,lo8(24)
 395 01b4 8093 0000 		sts outputByteHigh,r24
 961:vec9_io.c     **** 		outputByteMiddle|=Om_PUSHBUTTON_LAMP_1;
 396               		.loc 1 961 0
 397 01b8 85E0      		ldi r24,lo8(5)
 398 01ba 8093 0000 		sts outputByteMiddle,r24
 962:vec9_io.c     **** 		SetOutputs();
 399               		.loc 1 962 0
 400 01be 0E94 0000 		call SetOutputs
 401               	.LVL8:
 963:vec9_io.c     **** 		subState=SS_1;
 402               		.loc 1 963 0
 403 01c2 81E0      		ldi r24,lo8(1)
 404 01c4 00C0      		rjmp .L191
 405               	.L52:
 964:vec9_io.c     **** 	}
 965:vec9_io.c     **** 	else if(subState==SS_1)
 406               		.loc 1 965 0
 407 01c6 C130      		cpi r28,lo8(1)
 408 01c8 01F4      		brne .L54
 966:vec9_io.c     **** 	{
 967:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 409               		.loc 1 967 0
 410 01ca 80E0      		ldi r24,0
 411 01cc 0E94 0000 		call CheckTimer
 412               	.LVL9:
 413 01d0 8823      		tst r24
 414 01d2 01F4      		brne .+2
 415 01d4 00C0      		rjmp .L53
 968:vec9_io.c     **** 		{
 969:vec9_io.c     **** 			SetTimer(TIMER_1,(HORN_INTRO_TIME));
 416               		.loc 1 969 0
 417 01d6 6EEE      		ldi r22,lo8(-18)
 418 01d8 72E0      		ldi r23,lo8(2)
 419 01da 80E0      		ldi r24,0
 420 01dc 0E94 0000 		call SetTimer
 421               	.LVL10:
 970:vec9_io.c     **** 			outputByteMiddle=0;
 971:vec9_io.c     **** 			outputByteHigh=(Om_FLIGHT_IND_0|Om_FLIGHT_IND_1|Om_FLIGHT_IND_2|Om_FLIGHT_IND_3);
 422               		.loc 1 971 0
 423 01e0 8EE1      		ldi r24,lo8(30)
 424 01e2 8093 0000 		sts outputByteHigh,r24
 972:vec9_io.c     **** 			outputByteMiddle|=Om_PUSHBUTTON_LAMP_0;
 425               		.loc 1 972 0
 426 01e6 C2E0      		ldi r28,lo8(2)
 427 01e8 C093 0000 		sts outputByteMiddle,r28
 973:vec9_io.c     **** 			SetOutputs();
 428               		.loc 1 973 0
 429 01ec 0E94 0000 		call SetOutputs
 430               	.LVL11:
 974:vec9_io.c     **** 			subState=SS_2;	
 431               		.loc 1 974 0
 432 01f0 C093 0000 		sts subState,r28
 433 01f4 00C0      		rjmp .L53
 434               	.L54:
 975:vec9_io.c     **** 		}
 976:vec9_io.c     **** 	}
 977:vec9_io.c     **** 	else if(subState==SS_2)
 435               		.loc 1 977 0
 436 01f6 C230      		cpi r28,lo8(2)
 437 01f8 01F4      		brne .L56
 978:vec9_io.c     **** 	{
 979:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 438               		.loc 1 979 0
 439 01fa 80E0      		ldi r24,0
 440 01fc 0E94 0000 		call CheckTimer
 441               	.LVL12:
 442 0200 8823      		tst r24
 443 0202 01F4      		brne .+2
 444 0204 00C0      		rjmp .L53
 980:vec9_io.c     **** 		{
 981:vec9_io.c     **** 			SetTimer(TIMER_1,(HORN_INTRO_TIME));
 445               		.loc 1 981 0
 446 0206 6EEE      		ldi r22,lo8(-18)
 447 0208 72E0      		ldi r23,lo8(2)
 448 020a 80E0      		ldi r24,0
 449 020c 0E94 0000 		call SetTimer
 450               	.LVL13:
 982:vec9_io.c     **** 			outputByteMiddle=Om_AIR_HORN;
 983:vec9_io.c     **** 			outputByteHigh=(Om_FLIGHT_IND_2|Om_FLIGHT_IND_3|Om_FLIGHT_IND_4);
 451               		.loc 1 983 0
 452 0210 87E0      		ldi r24,lo8(7)
 453 0212 8093 0000 		sts outputByteHigh,r24
 984:vec9_io.c     **** 			outputByteMiddle|=Om_FLIGHT_IND_5;
 454               		.loc 1 984 0
 455 0216 84E8      		ldi r24,lo8(-124)
 456 0218 8093 0000 		sts outputByteMiddle,r24
 985:vec9_io.c     **** 			outputByteLow=Om_RED_LED_3;
 457               		.loc 1 985 0
 458 021c 81E0      		ldi r24,lo8(1)
 459 021e 8093 0000 		sts outputByteLow,r24
 986:vec9_io.c     **** 			SetOutputs();
 460               		.loc 1 986 0
 461 0222 0E94 0000 		call SetOutputs
 462               	.LVL14:
 987:vec9_io.c     **** 			subState=SS_3;	
 463               		.loc 1 987 0
 464 0226 83E0      		ldi r24,lo8(3)
 465               	.L191:
 466 0228 8093 0000 		sts subState,r24
 467 022c 00C0      		rjmp .L53
 468               	.L56:
 988:vec9_io.c     **** 		}
 989:vec9_io.c     **** 	}
 990:vec9_io.c     **** 	else if(subState==SS_3)
 469               		.loc 1 990 0
 470 022e C330      		cpi r28,lo8(3)
 471 0230 01F4      		brne .L58
 991:vec9_io.c     **** 	{
 992:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 472               		.loc 1 992 0
 473 0232 80E0      		ldi r24,0
 474 0234 0E94 0000 		call CheckTimer
 475               	.LVL15:
 476 0238 8823      		tst r24
 477 023a 01F4      		brne .+2
 478 023c 00C0      		rjmp .L53
 993:vec9_io.c     **** 		{
 994:vec9_io.c     **** 			SetTimer(TIMER_1,(HORN_INTRO_TIME));
 479               		.loc 1 994 0
 480 023e 6EEE      		ldi r22,lo8(-18)
 481 0240 72E0      		ldi r23,lo8(2)
 482 0242 80E0      		ldi r24,0
 483 0244 0E94 0000 		call SetTimer
 484               	.LVL16:
 995:vec9_io.c     **** 			outputByteMiddle=0;
 996:vec9_io.c     **** 			outputByteHigh=Om_FLIGHT_IND_4;
 485               		.loc 1 996 0
 486 0248 81E0      		ldi r24,lo8(1)
 487 024a 8093 0000 		sts outputByteHigh,r24
 997:vec9_io.c     **** 			outputByteMiddle|=(Om_FLIGHT_IND_5|Om_FLIGHT_IND_6|Om_FLIGHT_IND_7);
 488               		.loc 1 997 0
 489 024e 80EE      		ldi r24,lo8(-32)
 490 0250 8093 0000 		sts outputByteMiddle,r24
 998:vec9_io.c     **** 			outputByteLow=Om_RED_LED_2;
 491               		.loc 1 998 0
 492 0254 82E0      		ldi r24,lo8(2)
 493 0256 8093 0000 		sts outputByteLow,r24
 999:vec9_io.c     **** 			SetOutputs();
 494               		.loc 1 999 0
 495 025a 0E94 0000 		call SetOutputs
 496               	.LVL17:
1000:vec9_io.c     **** 			subState=SS_4;	
 497               		.loc 1 1000 0
 498 025e 84E0      		ldi r24,lo8(4)
 499 0260 00C0      		rjmp .L191
 500               	.L58:
1001:vec9_io.c     **** 		}
1002:vec9_io.c     **** 	}
1003:vec9_io.c     **** 	else if(subState==SS_4)
 501               		.loc 1 1003 0
 502 0262 C430      		cpi r28,lo8(4)
 503 0264 01F4      		brne .L59
1004:vec9_io.c     **** 	{
1005:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 504               		.loc 1 1005 0
 505 0266 80E0      		ldi r24,0
 506 0268 0E94 0000 		call CheckTimer
 507               	.LVL18:
 508 026c 8823      		tst r24
 509 026e 01F4      		brne .+2
 510 0270 00C0      		rjmp .L53
1006:vec9_io.c     **** 		{
1007:vec9_io.c     **** 			SetTimer(TIMER_1,(HORN_INTRO_TIME));
 511               		.loc 1 1007 0
 512 0272 6EEE      		ldi r22,lo8(-18)
 513 0274 72E0      		ldi r23,lo8(2)
 514 0276 80E0      		ldi r24,0
 515 0278 0E94 0000 		call SetTimer
 516               	.LVL19:
1008:vec9_io.c     **** 			outputByteMiddle=Om_AIR_HORN;
1009:vec9_io.c     **** 			outputByteHigh=0;
 517               		.loc 1 1009 0
 518 027c 1092 0000 		sts outputByteHigh,__zero_reg__
1010:vec9_io.c     **** 			outputByteMiddle|=(Om_FLIGHT_IND_6|Om_FLIGHT_IND_7|Om_FLIGHT_IND_8|Om_FLIGHT_IND_9);
 519               		.loc 1 1010 0
 520 0280 8CE7      		ldi r24,lo8(124)
 521 0282 8093 0000 		sts outputByteMiddle,r24
1011:vec9_io.c     **** 			outputByteLow=Om_RED_LED_1;
 522               		.loc 1 1011 0
 523 0286 C093 0000 		sts outputByteLow,r28
1012:vec9_io.c     **** 			SetOutputs();
 524               		.loc 1 1012 0
 525 028a 0E94 0000 		call SetOutputs
 526               	.LVL20:
1013:vec9_io.c     **** 			subState=SS_5;	
 527               		.loc 1 1013 0
 528 028e 85E0      		ldi r24,lo8(5)
 529 0290 00C0      		rjmp .L191
 530               	.L59:
1014:vec9_io.c     **** 		}
1015:vec9_io.c     **** 	}
1016:vec9_io.c     **** 	else if(subState==SS_5)
 531               		.loc 1 1016 0
 532 0292 C530      		cpi r28,lo8(5)
 533 0294 01F4      		brne .L60
1017:vec9_io.c     **** 	{
1018:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 534               		.loc 1 1018 0
 535 0296 80E0      		ldi r24,0
 536 0298 0E94 0000 		call CheckTimer
 537               	.LVL21:
 538 029c 8823      		tst r24
 539 029e 01F4      		brne .+2
 540 02a0 00C0      		rjmp .L53
1019:vec9_io.c     **** 		{
1020:vec9_io.c     **** 			SetTimer(TIMER_1,(HORN_INTRO_TIME));
 541               		.loc 1 1020 0
 542 02a2 6EEE      		ldi r22,lo8(-18)
 543 02a4 72E0      		ldi r23,lo8(2)
 544 02a6 80E0      		ldi r24,0
 545 02a8 0E94 0000 		call SetTimer
 546               	.LVL22:
1021:vec9_io.c     **** 			outputByteMiddle=0;
1022:vec9_io.c     **** 			outputByteMiddle|=(Om_FLIGHT_IND_8|Om_FLIGHT_IND_9);
 547               		.loc 1 1022 0
 548 02ac 88E1      		ldi r24,lo8(24)
 549 02ae 8093 0000 		sts outputByteMiddle,r24
1023:vec9_io.c     **** 			outputByteLow=Om_RED_LED_0;
 550               		.loc 1 1023 0
 551 02b2 88E0      		ldi r24,lo8(8)
 552 02b4 8093 0000 		sts outputByteLow,r24
1024:vec9_io.c     **** 			SetOutputs();
 553               		.loc 1 1024 0
 554 02b8 0E94 0000 		call SetOutputs
 555               	.LVL23:
1025:vec9_io.c     **** 			subState=SS_6;	
 556               		.loc 1 1025 0
 557 02bc 86E0      		ldi r24,lo8(6)
 558 02be 00C0      		rjmp .L191
 559               	.L60:
1026:vec9_io.c     **** 		}
1027:vec9_io.c     **** 	}
1028:vec9_io.c     **** 	else if(subState==SS_6)
 560               		.loc 1 1028 0
 561 02c0 C630      		cpi r28,lo8(6)
 562 02c2 01F4      		brne .L61
1029:vec9_io.c     **** 	{
1030:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 563               		.loc 1 1030 0
 564 02c4 80E0      		ldi r24,0
 565 02c6 0E94 0000 		call CheckTimer
 566               	.LVL24:
 567 02ca 8823      		tst r24
 568 02cc 01F4      		brne .+2
 569 02ce 00C0      		rjmp .L53
1031:vec9_io.c     **** 		{
1032:vec9_io.c     **** 			SetTimer(TIMER_1,(HORN_INTRO_TIME));
 570               		.loc 1 1032 0
 571 02d0 6EEE      		ldi r22,lo8(-18)
 572 02d2 72E0      		ldi r23,lo8(2)
 573 02d4 80E0      		ldi r24,0
 574 02d6 0E94 0000 		call SetTimer
 575               	.LVL25:
1033:vec9_io.c     **** 			outputByteMiddle=Om_AIR_HORN;
 576               		.loc 1 1033 0
 577 02da 84E0      		ldi r24,lo8(4)
 578 02dc 8093 0000 		sts outputByteMiddle,r24
1034:vec9_io.c     **** 			outputByteLow=(Om_GREEN_LED_0|Om_GREEN_LED_1|Om_GREEN_LED_2|Om_GREEN_LED_3);
 579               		.loc 1 1034 0
 580 02e0 80EF      		ldi r24,lo8(-16)
 581 02e2 8093 0000 		sts outputByteLow,r24
1035:vec9_io.c     **** 
1036:vec9_io.c     **** 			SetOutputs();
 582               		.loc 1 1036 0
 583 02e6 0E94 0000 		call SetOutputs
 584               	.LVL26:
1037:vec9_io.c     **** 			subState=SS_7;	
 585               		.loc 1 1037 0
 586 02ea 87E0      		ldi r24,lo8(7)
 587 02ec 00C0      		rjmp .L191
 588               	.L61:
1038:vec9_io.c     **** 		}
1039:vec9_io.c     **** 	}
1040:vec9_io.c     **** 	else if(subState==SS_7)
 589               		.loc 1 1040 0
 590 02ee C730      		cpi r28,lo8(7)
 591 02f0 01F4      		brne .L62
1041:vec9_io.c     **** 	{
1042:vec9_io.c     **** 		if(CheckTimer(TIMER_1))
 592               		.loc 1 1042 0
 593 02f2 80E0      		ldi r24,0
 594 02f4 0E94 0000 		call CheckTimer
 595               	.LVL27:
 596 02f8 8823      		tst r24
 597 02fa 01F4      		brne .+2
 598 02fc 00C0      		rjmp .L53
1043:vec9_io.c     **** 		{
1044:vec9_io.c     **** 			SetTimer(TIMER_1,(CHASE_TIME));
 599               		.loc 1 1044 0
 600 02fe 67E7      		ldi r22,lo8(119)
 601 0300 71E0      		ldi r23,lo8(1)
 602 0302 80E0      		ldi r24,0
 603 0304 0E94 0000 		call SetTimer
 604               	.LVL28:
1045:vec9_io.c     **** 			SetTimer(TIMER_2,(LAMP_TIME));
 605               		.loc 1 1045 0
 606 0308 60EA      		ldi r22,lo8(-96)
 607 030a 7FE0      		ldi r23,lo8(15)
 608 030c 81E0      		ldi r24,lo8(1)
 609 030e 0E94 0000 		call SetTimer
 610               	.LVL29:
1046:vec9_io.c     **** 
1047:vec9_io.c     **** 			outputByteHigh=0;
 611               		.loc 1 1047 0
 612 0312 1092 0000 		sts outputByteHigh,__zero_reg__
1048:vec9_io.c     **** 			outputByteMiddle=0;
 613               		.loc 1 1048 0
 614 0316 1092 0000 		sts outputByteMiddle,__zero_reg__
1049:vec9_io.c     **** 			outputByteLow=0;
 615               		.loc 1 1049 0
 616 031a 1092 0000 		sts outputByteLow,__zero_reg__
1050:vec9_io.c     **** 			SetOutputs();
 617               		.loc 1 1050 0
 618 031e 0E94 0000 		call SetOutputs
 619               	.LVL30:
1051:vec9_io.c     **** 
1052:vec9_io.c     **** 			shiftIndex=0;
 620               		.loc 1 1052 0
 621 0322 1092 0000 		sts shiftIndex.3940,__zero_reg__
1053:vec9_io.c     **** 			lampCounter=0;
 622               		.loc 1 1053 0
 623 0326 1092 0000 		sts lampCounter.3941,__zero_reg__
1054:vec9_io.c     **** 
1055:vec9_io.c     **** 			subState=SS_8;	
 624               		.loc 1 1055 0
 625 032a 88E0      		ldi r24,lo8(8)
 626 032c 00C0      		rjmp .L191
 627               	.L62:
1056:vec9_io.c     **** 		}
1057:vec9_io.c     **** 	}	
1058:vec9_io.c     **** 	// LIGHT CHASE -----------------------------
1059:vec9_io.c     **** 	else if(subState==SS_8)
 628               		.loc 1 1059 0
 629 032e C830      		cpi r28,lo8(8)
 630 0330 01F0      		breq .+2
 631 0332 00C0      		rjmp .L53
1060:vec9_io.c     **** 	{
1061:vec9_io.c     **** 		lastOutputByteHigh=outputByteHigh;
 632               		.loc 1 1061 0
 633 0334 8091 0000 		lds r24,outputByteHigh
 634 0338 8093 0000 		sts lastOutputByteHigh.3937,r24
1062:vec9_io.c     **** 		lastOutputByteMiddle=outputByteMiddle;
 635               		.loc 1 1062 0
 636 033c 8091 0000 		lds r24,outputByteMiddle
 637 0340 8093 0000 		sts lastOutputByteMiddle.3938,r24
1063:vec9_io.c     **** 		lastOutputByteLow=outputByteLow;
 638               		.loc 1 1063 0
 639 0344 8091 0000 		lds r24,outputByteLow
 640 0348 8093 0000 		sts lastOutputByteLow.3939,r24
1064:vec9_io.c     **** 	
1065:vec9_io.c     **** 		if(CheckTimer(TIMER_1))		// Update Green LEDs
 641               		.loc 1 1065 0
 642 034c 80E0      		ldi r24,0
 643 034e 0E94 0000 		call CheckTimer
 644               	.LVL31:
 645 0352 8823      		tst r24
 646 0354 01F0      		breq .L63
1066:vec9_io.c     **** 		{
1067:vec9_io.c     **** 			shiftIndex++;
 647               		.loc 1 1067 0
 648 0356 9091 0000 		lds r25,shiftIndex.3940
 649 035a 9F5F      		subi r25,lo8(-(1))
 650 035c 9093 0000 		sts shiftIndex.3940,r25
1068:vec9_io.c     **** 
1069:vec9_io.c     **** 			if(shiftIndex<5)	// LEDs marching up
 651               		.loc 1 1069 0
 652 0360 9530      		cpi r25,lo8(5)
 653 0362 00F4      		brsh .L64
1070:vec9_io.c     **** 			{
1071:vec9_io.c     **** 				// Clear Green LEDs
1072:vec9_io.c     **** 				outputByteLow&=~(Om_GREEN_LED_0|Om_GREEN_LED_1|Om_GREEN_LED_2|Om_GREEN_LED_3);
 654               		.loc 1 1072 0
 655 0364 8091 0000 		lds r24,outputByteLow
 656 0368 8F70      		andi r24,lo8(15)
1073:vec9_io.c     **** 
1074:vec9_io.c     **** 				if(shiftIndex>=1)
 657               		.loc 1 1074 0
 658 036a 9923      		tst r25
 659 036c 01F0      		breq .L185
1075:vec9_io.c     **** 				{
1076:vec9_io.c     **** 					outputByteLow|=Om_GREEN_LED_0;
1077:vec9_io.c     **** 				}
1078:vec9_io.c     **** 				if(shiftIndex>=2)
 660               		.loc 1 1078 0
 661 036e 9130      		cpi r25,lo8(1)
 662 0370 01F4      		brne .L66
1076:vec9_io.c     **** 				}
 663               		.loc 1 1076 0
 664 0372 8068      		ori r24,lo8(-128)
 665 0374 00C0      		rjmp .L185
 666               	.L66:
1079:vec9_io.c     **** 				{
1080:vec9_io.c     **** 					outputByteLow|=Om_GREEN_LED_1;
1081:vec9_io.c     **** 				}
1082:vec9_io.c     **** 				if(shiftIndex>=3)
 667               		.loc 1 1082 0
 668 0376 9230      		cpi r25,lo8(2)
 669 0378 01F4      		brne .L68
1080:vec9_io.c     **** 				}
 670               		.loc 1 1080 0
 671 037a 806C      		ori r24,lo8(-64)
 672 037c 00C0      		rjmp .L185
 673               	.L68:
1083:vec9_io.c     **** 				{
1084:vec9_io.c     **** 					outputByteLow|=Om_GREEN_LED_2;
1085:vec9_io.c     **** 				}
1086:vec9_io.c     **** 				if(shiftIndex>=4)
 674               		.loc 1 1086 0
 675 037e 9430      		cpi r25,lo8(4)
 676 0380 01F0      		breq .L70
1084:vec9_io.c     **** 				}
 677               		.loc 1 1084 0
 678 0382 806E      		ori r24,lo8(-32)
 679 0384 00C0      		rjmp .L185
 680               	.L70:
1087:vec9_io.c     **** 				{
1088:vec9_io.c     **** 					outputByteLow|=Om_GREEN_LED_3;
 681               		.loc 1 1088 0
 682 0386 806F      		ori r24,lo8(-16)
 683 0388 00C0      		rjmp .L185
 684               	.L64:
1089:vec9_io.c     **** 				}
1090:vec9_io.c     **** 			}
1091:vec9_io.c     **** 			else if(shiftIndex<9)	// Leds marching off
 685               		.loc 1 1091 0
 686 038a 9930      		cpi r25,lo8(9)
 687 038c 00F4      		brsh .L72
1092:vec9_io.c     **** 			{
1093:vec9_io.c     **** 				// Set Green LEDs
1094:vec9_io.c     **** 				outputByteLow|=(Om_GREEN_LED_0|Om_GREEN_LED_1|Om_GREEN_LED_2|Om_GREEN_LED_3);
 688               		.loc 1 1094 0
 689 038e 8091 0000 		lds r24,outputByteLow
1095:vec9_io.c     **** 
1096:vec9_io.c     **** 				if(shiftIndex>=5)
1097:vec9_io.c     **** 				{
1098:vec9_io.c     **** 					outputByteLow&=~Om_GREEN_LED_0;
1099:vec9_io.c     **** 				}
1100:vec9_io.c     **** 				if(shiftIndex>=6)
 690               		.loc 1 1100 0
 691 0392 9530      		cpi r25,lo8(5)
 692 0394 01F4      		brne .L73
1098:vec9_io.c     **** 				}
 693               		.loc 1 1098 0
 694 0396 8F77      		andi r24,lo8(127)
 695 0398 8067      		ori r24,lo8(112)
 696 039a 00C0      		rjmp .L185
 697               	.L73:
1101:vec9_io.c     **** 				{
1102:vec9_io.c     **** 					outputByteLow&=~Om_GREEN_LED_1;
1103:vec9_io.c     **** 				}
1104:vec9_io.c     **** 				if(shiftIndex>=7)
 698               		.loc 1 1104 0
 699 039c 9630      		cpi r25,lo8(6)
 700 039e 01F4      		brne .L75
1102:vec9_io.c     **** 				}
 701               		.loc 1 1102 0
 702 03a0 8F73      		andi r24,lo8(63)
 703 03a2 8063      		ori r24,lo8(48)
 704 03a4 00C0      		rjmp .L185
 705               	.L75:
1105:vec9_io.c     **** 				{
1106:vec9_io.c     **** 					outputByteLow&=~Om_GREEN_LED_2;
1107:vec9_io.c     **** 				}
1108:vec9_io.c     **** 				if(shiftIndex>=8)
 706               		.loc 1 1108 0
 707 03a6 9830      		cpi r25,lo8(8)
 708 03a8 01F0      		breq .L192
1106:vec9_io.c     **** 				}
 709               		.loc 1 1106 0
 710 03aa 8F71      		andi r24,lo8(31)
 711 03ac 8061      		ori r24,lo8(16)
 712               	.L185:
 713 03ae 8093 0000 		sts outputByteLow,r24
 714 03b2 00C0      		rjmp .L71
 715               	.L72:
1109:vec9_io.c     **** 				{
1110:vec9_io.c     **** 					outputByteLow&=~Om_GREEN_LED_3;
1111:vec9_io.c     **** 				}			
1112:vec9_io.c     **** 			}
1113:vec9_io.c     **** 			else if(shiftIndex<13)	// No green LEDs, pause
 716               		.loc 1 1113 0
 717 03b4 9D30      		cpi r25,lo8(13)
 718 03b6 00F4      		brsh .L78
1114:vec9_io.c     **** 			{
1115:vec9_io.c     **** 				outputByteLow&=~(Om_GREEN_LED_0|Om_GREEN_LED_1|Om_GREEN_LED_2|Om_GREEN_LED_3);
 719               		.loc 1 1115 0
 720 03b8 8091 0000 		lds r24,outputByteLow
 721               	.L192:
 722 03bc 8F70      		andi r24,lo8(15)
 723 03be 00C0      		rjmp .L185
 724               	.L78:
1116:vec9_io.c     **** 			}
1117:vec9_io.c     **** 			else
1118:vec9_io.c     **** 			{
1119:vec9_io.c     **** 				shiftIndex=0;
 725               		.loc 1 1119 0
 726 03c0 1092 0000 		sts shiftIndex.3940,__zero_reg__
 727               	.L71:
1120:vec9_io.c     **** 			}
1121:vec9_io.c     **** 
1122:vec9_io.c     **** 			SetTimer(TIMER_1,(CHASE_TIME));
 728               		.loc 1 1122 0
 729 03c4 67E7      		ldi r22,lo8(119)
 730 03c6 71E0      		ldi r23,lo8(1)
 731 03c8 80E0      		ldi r24,0
 732 03ca 0E94 0000 		call SetTimer
 733               	.LVL32:
 734               	.L63:
1123:vec9_io.c     **** 		}
1124:vec9_io.c     **** 		
1125:vec9_io.c     **** 		if(CheckTimer(TIMER_2))		// Chase pushbutton lamps if we aren't fussing with them
 735               		.loc 1 1125 0
 736 03ce 81E0      		ldi r24,lo8(1)
 737 03d0 0E94 0000 		call CheckTimer
 738               	.LVL33:
 739 03d4 8823      		tst r24
 740 03d6 01F0      		breq .L79
1126:vec9_io.c     **** 		{
1127:vec9_io.c     **** 			lampCounter++;
 741               		.loc 1 1127 0
 742 03d8 8091 0000 		lds r24,lampCounter.3941
 743 03dc 8F5F      		subi r24,lo8(-(1))
1128:vec9_io.c     **** 			if(lampCounter>=4)
 744               		.loc 1 1128 0
 745 03de 8430      		cpi r24,lo8(4)
 746 03e0 00F4      		brsh .L80
1127:vec9_io.c     **** 			if(lampCounter>=4)
 747               		.loc 1 1127 0
 748 03e2 8093 0000 		sts lampCounter.3941,r24
 749 03e6 00C0      		rjmp .L81
 750               	.L80:
1129:vec9_io.c     **** 			{
1130:vec9_io.c     **** 				lampCounter=0;
 751               		.loc 1 1130 0
 752 03e8 1092 0000 		sts lampCounter.3941,__zero_reg__
 753               	.L81:
1131:vec9_io.c     **** 			}
1132:vec9_io.c     **** 
1133:vec9_io.c     **** 			outputByteMiddle&=~Om_PUSHBUTTON_LAMP_0;		
1134:vec9_io.c     **** 			outputByteMiddle&=~Om_PUSHBUTTON_LAMP_1;		
 754               		.loc 1 1134 0
 755 03ec 8091 0000 		lds r24,outputByteMiddle
 756 03f0 8C7F      		andi r24,lo8(-4)
 757 03f2 8093 0000 		sts outputByteMiddle,r24
1135:vec9_io.c     **** 
1136:vec9_io.c     **** 			if(lampCounter&0x01)
 758               		.loc 1 1136 0
 759 03f6 9091 0000 		lds r25,lampCounter.3941
 760 03fa 90FF      		sbrs r25,0
 761 03fc 00C0      		rjmp .L82
1137:vec9_io.c     **** 			{
1138:vec9_io.c     **** 				outputByteMiddle|=Om_PUSHBUTTON_LAMP_0;
 762               		.loc 1 1138 0
 763 03fe 8260      		ori r24,lo8(2)
 764 0400 8093 0000 		sts outputByteMiddle,r24
 765               	.L82:
1139:vec9_io.c     **** 			}
1140:vec9_io.c     **** 			if(lampCounter&0x02)
 766               		.loc 1 1140 0
 767 0404 91FF      		sbrs r25,1
 768 0406 00C0      		rjmp .L83
1141:vec9_io.c     **** 			{
1142:vec9_io.c     **** 				outputByteMiddle|=Om_PUSHBUTTON_LAMP_1;
 769               		.loc 1 1142 0
 770 0408 8091 0000 		lds r24,outputByteMiddle
 771 040c 8160      		ori r24,lo8(1)
 772 040e 8093 0000 		sts outputByteMiddle,r24
 773               	.L83:
1143:vec9_io.c     **** 			}
1144:vec9_io.c     **** 
1145:vec9_io.c     **** 			SetTimer(TIMER_2,(LAMP_TIME));
 774               		.loc 1 1145 0
 775 0412 60EA      		ldi r22,lo8(-96)
 776 0414 7FE0      		ldi r23,lo8(15)
 777 0416 81E0      		ldi r24,lo8(1)
 778 0418 0E94 0000 		call SetTimer
 779               	.LVL34:
 780               	.L79:
1146:vec9_io.c     **** 		}
1147:vec9_io.c     **** 
1148:vec9_io.c     **** 		// Set pushbutton lamps if we're holding them, clear on release
1149:vec9_io.c     **** 		if(keyState&Im_PUSHBUTTON_0)		
 781               		.loc 1 1149 0
 782 041c 8091 0000 		lds r24,keyState
 783 0420 9091 0000 		lds r25,keyState+1
 784 0424 2091 0000 		lds r18,outputByteMiddle
 785 0428 92FF      		sbrs r25,2
 786 042a 00C0      		rjmp .L84
1150:vec9_io.c     **** 		{
1151:vec9_io.c     **** 			outputByteMiddle|=Om_PUSHBUTTON_LAMP_0;
 787               		.loc 1 1151 0
 788 042c 2260      		ori r18,lo8(2)
 789 042e 00C0      		rjmp .L186
 790               	.L84:
1152:vec9_io.c     **** 		}
1153:vec9_io.c     **** 		else if(newKeysReleased&Im_PUSHBUTTON_0)
 791               		.loc 1 1153 0
 792 0430 4091 0000 		lds r20,newKeysReleased
 793 0434 5091 0000 		lds r21,newKeysReleased+1
 794 0438 52FF      		sbrs r21,2
 795 043a 00C0      		rjmp .L85
1154:vec9_io.c     **** 		{
1155:vec9_io.c     **** 			outputByteMiddle&=~Om_PUSHBUTTON_LAMP_0;		
 796               		.loc 1 1155 0
 797 043c 2D7F      		andi r18,lo8(-3)
 798               	.L186:
 799 043e 2093 0000 		sts outputByteMiddle,r18
 800               	.L85:
 801 0442 2091 0000 		lds r18,outputByteMiddle
1156:vec9_io.c     **** 		}
1157:vec9_io.c     **** 
1158:vec9_io.c     **** 		if(keyState&Im_PUSHBUTTON_1)		
 802               		.loc 1 1158 0
 803 0446 93FF      		sbrs r25,3
 804 0448 00C0      		rjmp .L86
1159:vec9_io.c     **** 		{
1160:vec9_io.c     **** 			outputByteMiddle|=Om_PUSHBUTTON_LAMP_1;
 805               		.loc 1 1160 0
 806 044a 2160      		ori r18,lo8(1)
 807 044c 00C0      		rjmp .L187
 808               	.L86:
1161:vec9_io.c     **** 		}
1162:vec9_io.c     **** 		else if(newKeysReleased&Im_PUSHBUTTON_1)
 809               		.loc 1 1162 0
 810 044e 4091 0000 		lds r20,newKeysReleased
 811 0452 5091 0000 		lds r21,newKeysReleased+1
 812 0456 53FF      		sbrs r21,3
 813 0458 00C0      		rjmp .L87
1163:vec9_io.c     **** 		{
1164:vec9_io.c     **** 			outputByteMiddle&=~Om_PUSHBUTTON_LAMP_1;		
 814               		.loc 1 1164 0
 815 045a 2E7F      		andi r18,lo8(-2)
 816               	.L187:
 817 045c 2093 0000 		sts outputByteMiddle,r18
 818               	.L87:
1165:vec9_io.c     **** 		}
1166:vec9_io.c     **** 
1167:vec9_io.c     **** 		// Clear flight indicators
1168:vec9_io.c     **** 		outputByteHigh=0;
 819               		.loc 1 1168 0
 820 0460 1092 0000 		sts outputByteHigh,__zero_reg__
1169:vec9_io.c     **** 		outputByteMiddle&=~(Om_FLIGHT_IND_5|Om_FLIGHT_IND_6|Om_FLIGHT_IND_7|Om_FLIGHT_IND_8|Om_FLIGHT_IND
 821               		.loc 1 1169 0
 822 0464 2091 0000 		lds r18,outputByteMiddle
 823 0468 2770      		andi r18,lo8(7)
 824 046a 2093 0000 		sts outputByteMiddle,r18
1170:vec9_io.c     **** 		
1171:vec9_io.c     **** 		// Clear Red LEDs
1172:vec9_io.c     **** 		outputByteLow&=~(Om_RED_LED_0|Om_RED_LED_1|Om_RED_LED_2|Om_RED_LED_3);
 825               		.loc 1 1172 0
 826 046e 3091 0000 		lds r19,outputByteLow
 827 0472 307F      		andi r19,lo8(-16)
1173:vec9_io.c     **** 
1174:vec9_io.c     **** 		// Put toggle switches directly on red LEDs
1175:vec9_io.c     **** 		if(keyState&Im_TOGGLE_0)		
 828               		.loc 1 1175 0
 829 0474 86FD      		sbrc r24,6
1176:vec9_io.c     **** 		{
1177:vec9_io.c     **** 			outputByteLow|=Om_RED_LED_0;
 830               		.loc 1 1177 0
 831 0476 3860      		ori r19,lo8(8)
 832               	.L188:
 833 0478 3093 0000 		sts outputByteLow,r19
1178:vec9_io.c     **** 		}
1179:vec9_io.c     **** 		if(keyState&Im_TOGGLE_1)		
 834               		.loc 1 1179 0
 835 047c 87FF      		sbrs r24,7
 836 047e 00C0      		rjmp .L90
1180:vec9_io.c     **** 		{
1181:vec9_io.c     **** 			outputByteLow|=Om_RED_LED_1;
 837               		.loc 1 1181 0
 838 0480 3091 0000 		lds r19,outputByteLow
 839 0484 3460      		ori r19,lo8(4)
 840 0486 3093 0000 		sts outputByteLow,r19
 841               	.L90:
1182:vec9_io.c     **** 		}
1183:vec9_io.c     **** 		if(keyState&Im_TOGGLE_2)		
 842               		.loc 1 1183 0
 843 048a 90FF      		sbrs r25,0
 844 048c 00C0      		rjmp .L91
1184:vec9_io.c     **** 		{
1185:vec9_io.c     **** 			outputByteLow|=Om_RED_LED_2;
 845               		.loc 1 1185 0
 846 048e 3091 0000 		lds r19,outputByteLow
 847 0492 3260      		ori r19,lo8(2)
 848 0494 3093 0000 		sts outputByteLow,r19
 849               	.L91:
1186:vec9_io.c     **** 		}
1187:vec9_io.c     **** 		if(keyState&Im_TOGGLE_3)		
 850               		.loc 1 1187 0
 851 0498 91FF      		sbrs r25,1
 852 049a 00C0      		rjmp .L92
1188:vec9_io.c     **** 		{
1189:vec9_io.c     **** 			outputByteLow|=Om_RED_LED_3;
 853               		.loc 1 1189 0
 854 049c 3091 0000 		lds r19,outputByteLow
 855 04a0 3160      		ori r19,lo8(1)
 856 04a2 3093 0000 		sts outputByteLow,r19
 857               	.L92:
1190:vec9_io.c     **** 		}
1191:vec9_io.c     **** 
1192:vec9_io.c     **** 		// Triggers to flight indicators
1193:vec9_io.c     **** 
1194:vec9_io.c     **** 		if(keyState&Im_R_MAIN_TRIG)
 858               		.loc 1 1194 0
 859 04a6 80FF      		sbrs r24,0
 860 04a8 00C0      		rjmp .L93
1195:vec9_io.c     **** 		{
1196:vec9_io.c     **** 			outputByteHigh|=Om_FLIGHT_IND_0;
 861               		.loc 1 1196 0
 862 04aa 30E1      		ldi r19,lo8(16)
 863 04ac 3093 0000 		sts outputByteHigh,r19
 864               	.L93:
1197:vec9_io.c     **** 		}
1198:vec9_io.c     **** 		if(keyState&Im_R_THUMB_TRIG)
 865               		.loc 1 1198 0
 866 04b0 81FF      		sbrs r24,1
 867 04b2 00C0      		rjmp .L94
1199:vec9_io.c     **** 		{
1200:vec9_io.c     **** 			outputByteHigh|=Om_FLIGHT_IND_1;
 868               		.loc 1 1200 0
 869 04b4 3091 0000 		lds r19,outputByteHigh
 870 04b8 3860      		ori r19,lo8(8)
 871 04ba 3093 0000 		sts outputByteHigh,r19
 872               	.L94:
1201:vec9_io.c     **** 		}
1202:vec9_io.c     **** 		if(keyState&Im_R_GRIP_TRIG)
 873               		.loc 1 1202 0
 874 04be 82FF      		sbrs r24,2
 875 04c0 00C0      		rjmp .L95
1203:vec9_io.c     **** 		{
1204:vec9_io.c     **** 			outputByteHigh|=Om_FLIGHT_IND_2;
 876               		.loc 1 1204 0
 877 04c2 3091 0000 		lds r19,outputByteHigh
 878 04c6 3460      		ori r19,lo8(4)
 879 04c8 3093 0000 		sts outputByteHigh,r19
 880               	.L95:
1205:vec9_io.c     **** 		}
1206:vec9_io.c     **** 		if(keyState&Im_L_MAIN_TRIG)
 881               		.loc 1 1206 0
 882 04cc 83FF      		sbrs r24,3
 883 04ce 00C0      		rjmp .L96
1207:vec9_io.c     **** 		{
1208:vec9_io.c     **** 			outputByteHigh|=Om_FLIGHT_IND_3;
 884               		.loc 1 1208 0
 885 04d0 3091 0000 		lds r19,outputByteHigh
 886 04d4 3260      		ori r19,lo8(2)
 887 04d6 3093 0000 		sts outputByteHigh,r19
 888               	.L96:
1209:vec9_io.c     **** 		}
1210:vec9_io.c     **** 		if(keyState&Im_L_THUMB_TRIG)
 889               		.loc 1 1210 0
 890 04da 84FF      		sbrs r24,4
 891 04dc 00C0      		rjmp .L97
1211:vec9_io.c     **** 		{
1212:vec9_io.c     **** 			outputByteHigh|=Om_FLIGHT_IND_4;
 892               		.loc 1 1212 0
 893 04de 3091 0000 		lds r19,outputByteHigh
 894 04e2 3160      		ori r19,lo8(1)
 895 04e4 3093 0000 		sts outputByteHigh,r19
 896               	.L97:
1213:vec9_io.c     **** 		}
1214:vec9_io.c     **** 		if(keyState&Im_L_GRIP_TRIG)
 897               		.loc 1 1214 0
 898 04e8 85FF      		sbrs r24,5
 899 04ea 00C0      		rjmp .L98
1215:vec9_io.c     **** 		{
1216:vec9_io.c     **** 			outputByteMiddle|=Om_FLIGHT_IND_5;
 900               		.loc 1 1216 0
 901 04ec 2068      		ori r18,lo8(-128)
 902 04ee 2093 0000 		sts outputByteMiddle,r18
 903               	.L98:
1217:vec9_io.c     **** 		}
1218:vec9_io.c     **** 
1219:vec9_io.c     **** 		// Analog to flight indicators
1220:vec9_io.c     **** 
1221:vec9_io.c     **** 		if(newAdcResult[ADC_YOKE_PITCH]==true)
 904               		.loc 1 1221 0
 905 04f2 2091 0000 		lds r18,newAdcResult
 906 04f6 2130      		cpi r18,lo8(1)
 907 04f8 01F4      		brne .L99
1222:vec9_io.c     **** 		{
1223:vec9_io.c     **** 			analogPitch=(unsigned char)(adcResults[ADC_YOKE_PITCH]/8);		// Get back to 8 bits
 908               		.loc 1 1223 0
 909 04fa 2091 0000 		lds r18,adcResults
 910 04fe 3091 0000 		lds r19,adcResults+1
 911 0502 53E0      		ldi r21,3
 912               		1:
 913 0504 3695      		lsr r19
 914 0506 2795      		ror r18
 915 0508 5A95      		dec r21
 916 050a 01F4      		brne 1b
 917 050c 2093 0000 		sts analogPitch,r18
 918               	.L99:
1224:vec9_io.c     **** 		}
1225:vec9_io.c     **** 		if(newAdcResult[ADC_YOKE_ROLL]==true)
 919               		.loc 1 1225 0
 920 0510 2091 0000 		lds r18,newAdcResult+1
 921 0514 2130      		cpi r18,lo8(1)
 922 0516 01F4      		brne .L100
1226:vec9_io.c     **** 		{
1227:vec9_io.c     **** 			analogRoll=(unsigned char)(adcResults[ADC_YOKE_ROLL]/8);		// Get back to 8 bits
 923               		.loc 1 1227 0
 924 0518 2091 0000 		lds r18,adcResults+2
 925 051c 3091 0000 		lds r19,adcResults+2+1
 926 0520 43E0      		ldi r20,3
 927               		1:
 928 0522 3695      		lsr r19
 929 0524 2795      		ror r18
 930 0526 4A95      		dec r20
 931 0528 01F4      		brne 1b
 932 052a 2093 0000 		sts analogRoll,r18
 933               	.L100:
1228:vec9_io.c     **** 		}
1229:vec9_io.c     **** 
1230:vec9_io.c     **** 		if(analogPitch<70)
 934               		.loc 1 1230 0
 935 052e 2091 0000 		lds r18,analogPitch
 936 0532 2634      		cpi r18,lo8(70)
 937 0534 00F4      		brsh .L101
1231:vec9_io.c     **** 		{
1232:vec9_io.c     **** 			outputByteMiddle|=Om_FLIGHT_IND_6;
 938               		.loc 1 1232 0
 939 0536 2091 0000 		lds r18,outputByteMiddle
 940 053a 2064      		ori r18,lo8(64)
 941 053c 00C0      		rjmp .L189
 942               	.L101:
1233:vec9_io.c     **** 		}
1234:vec9_io.c     **** 		if(analogPitch>140)
 943               		.loc 1 1234 0
 944 053e 2D38      		cpi r18,lo8(-115)
 945 0540 00F0      		brlo .L102
1235:vec9_io.c     **** 		{
1236:vec9_io.c     **** 			outputByteMiddle|=Om_FLIGHT_IND_7;
 946               		.loc 1 1236 0
 947 0542 2091 0000 		lds r18,outputByteMiddle
 948 0546 2062      		ori r18,lo8(32)
 949               	.L189:
 950 0548 2093 0000 		sts outputByteMiddle,r18
 951               	.L102:
1237:vec9_io.c     **** 		}
1238:vec9_io.c     **** 		if(analogRoll<100)
 952               		.loc 1 1238 0
 953 054c 2091 0000 		lds r18,analogRoll
 954 0550 2436      		cpi r18,lo8(100)
 955 0552 00F4      		brsh .L103
1239:vec9_io.c     **** 		{
1240:vec9_io.c     **** 			outputByteMiddle|=Om_FLIGHT_IND_8;
 956               		.loc 1 1240 0
 957 0554 2091 0000 		lds r18,outputByteMiddle
 958 0558 2061      		ori r18,lo8(16)
 959 055a 00C0      		rjmp .L190
 960               	.L103:
1241:vec9_io.c     **** 		}
1242:vec9_io.c     **** 		if(analogRoll>130)
 961               		.loc 1 1242 0
 962 055c 2338      		cpi r18,lo8(-125)
 963 055e 00F0      		brlo .L104
1243:vec9_io.c     **** 		{
1244:vec9_io.c     **** 			outputByteMiddle|=Om_FLIGHT_IND_9;
 964               		.loc 1 1244 0
 965 0560 2091 0000 		lds r18,outputByteMiddle
 966 0564 2860      		ori r18,lo8(8)
 967               	.L190:
 968 0566 2093 0000 		sts outputByteMiddle,r18
 969               	.L104:
1245:vec9_io.c     **** 		}
1246:vec9_io.c     **** 
1247:vec9_io.c     **** 		// Sound of the police
1248:vec9_io.c     **** 		if(keyState&Im_COIN)
 970               		.loc 1 1248 0
 971 056a 94FF      		sbrs r25,4
 972 056c 00C0      		rjmp .L105
1249:vec9_io.c     **** 		{
1250:vec9_io.c     **** 			SetTimer(TIMER_3,(SECOND));
 973               		.loc 1 1250 0
 974 056e 68EB      		ldi r22,lo8(-72)
 975 0570 7BE0      		ldi r23,lo8(11)
 976 0572 82E0      		ldi r24,lo8(2)
 977 0574 0E94 0000 		call SetTimer
 978               	.LVL35:
1251:vec9_io.c     **** 			outputByteMiddle|=Om_AIR_HORN;
 979               		.loc 1 1251 0
 980 0578 8091 0000 		lds r24,outputByteMiddle
 981 057c 8460      		ori r24,lo8(4)
 982 057e 8093 0000 		sts outputByteMiddle,r24
 983               	.L105:
1252:vec9_io.c     **** 		}
1253:vec9_io.c     **** 
1254:vec9_io.c     **** 		if(CheckTimer(TIMER_3))
 984               		.loc 1 1254 0
 985 0582 82E0      		ldi r24,lo8(2)
 986 0584 0E94 0000 		call CheckTimer
 987               	.LVL36:
 988 0588 8823      		tst r24
 989 058a 01F0      		breq .L106
1255:vec9_io.c     **** 		{
1256:vec9_io.c     **** 			outputByteMiddle&=~Om_AIR_HORN;			
 990               		.loc 1 1256 0
 991 058c 8091 0000 		lds r24,outputByteMiddle
 992 0590 8B7F      		andi r24,lo8(-5)
 993 0592 8093 0000 		sts outputByteMiddle,r24
 994               	.L106:
1257:vec9_io.c     **** 		}
1258:vec9_io.c     **** 
1259:vec9_io.c     **** 		// Test button resets chases
1260:vec9_io.c     **** 		if(keyState&Im_TEST)
 995               		.loc 1 1260 0
 996 0596 8091 0000 		lds r24,keyState
 997 059a 9091 0000 		lds r25,keyState+1
 998 059e 95FD      		sbrc r25,5
1261:vec9_io.c     **** 		{
1262:vec9_io.c     **** 			subState=SS_0;
 999               		.loc 1 1262 0
 1000 05a0 1092 0000 		sts subState,__zero_reg__
 1001               	.L107:
1263:vec9_io.c     **** 		}
1264:vec9_io.c     **** 
1265:vec9_io.c     **** 		if((lastOutputByteHigh!=outputByteHigh)||(lastOutputByteMiddle!=outputByteMiddle)||(lastOutputByt
 1002               		.loc 1 1265 0
 1003 05a4 9091 0000 		lds r25,lastOutputByteHigh.3937
 1004 05a8 8091 0000 		lds r24,outputByteHigh
 1005 05ac 9813      		cpse r25,r24
 1006 05ae 00C0      		rjmp .L108
 1007               		.loc 1 1265 0 is_stmt 0 discriminator 1
 1008 05b0 9091 0000 		lds r25,lastOutputByteMiddle.3938
 1009 05b4 8091 0000 		lds r24,outputByteMiddle
 1010 05b8 9813      		cpse r25,r24
 1011 05ba 00C0      		rjmp .L108
 1012               		.loc 1 1265 0 discriminator 2
 1013 05bc 9091 0000 		lds r25,lastOutputByteLow.3939
 1014 05c0 8091 0000 		lds r24,outputByteLow
 1015 05c4 9813      		cpse r25,r24
 1016               	.L108:
1266:vec9_io.c     **** 		{
1267:vec9_io.c     **** 			SetOutputs();
 1017               		.loc 1 1267 0 is_stmt 1
 1018 05c6 0E94 0000 		call SetOutputs
 1019               	.LVL37:
 1020               	.L53:
 1021               	.LBB10:
 1022               	.LBB11:
 271:vec9_io.c     **** 	cli();
 1023               		.loc 1 271 0
 1024 05ca 9FB7      		in r25,__SREG__
 1025               	.LVL38:
 272:vec9_io.c     **** 
 1026               		.loc 1 272 0
 1027               	/* #APP */
 1028               	 ;  272 "vec9_io.c" 1
 1029 05cc F894      		cli
 1030               	 ;  0 "" 2
 1031               	.LVL39:
 275:vec9_io.c     **** 	{
 1032               		.loc 1 275 0
 1033               	/* #NOAPP */
 1034 05ce 8091 0000 		lds r24,bytesInRxFifo
 1035               	.LVL40:
 280:vec9_io.c     **** 	return(retVal);
 1036               		.loc 1 280 0
 1037 05d2 9FBF      		out __SREG__,r25
 1038               	.LBE11:
 1039               	.LBE10:
1268:vec9_io.c     **** 		}
1269:vec9_io.c     **** 	}
1270:vec9_io.c     **** 
1271:vec9_io.c     **** 	if(RxFifoNotEmpty())		// Once the game takes control, stop messing with outputs.
 1040               		.loc 1 1271 0
 1041 05d4 8823      		tst r24
 1042 05d6 01F0      		breq .L51
1272:vec9_io.c     **** 	{
1273:vec9_io.c     **** 		outputByteHigh=0;
 1043               		.loc 1 1273 0
 1044 05d8 1092 0000 		sts outputByteHigh,__zero_reg__
1274:vec9_io.c     **** 		outputByteMiddle=0;
 1045               		.loc 1 1274 0
 1046 05dc 1092 0000 		sts outputByteMiddle,__zero_reg__
1275:vec9_io.c     **** 		outputByteLow=0;
 1047               		.loc 1 1275 0
 1048 05e0 1092 0000 		sts outputByteLow,__zero_reg__
1276:vec9_io.c     **** 		SetOutputs();
 1049               		.loc 1 1276 0
 1050 05e4 0E94 0000 		call SetOutputs
 1051               	.LVL41:
 1052               	.LBB12:
 1053               	.LBB13:
 107:vec9_io.c     **** 	subState=SS_0;
 1054               		.loc 1 107 0
 1055 05e8 80E0      		ldi r24,lo8(gs(DoUpdateIo))
 1056 05ea 90E0      		ldi r25,hi8(gs(DoUpdateIo))
 1057 05ec 8093 0000 		sts State,r24
 1058 05f0 9093 0000 		sts State+1,r25
 108:vec9_io.c     **** }
 1059               		.loc 1 108 0
 1060 05f4 1092 0000 		sts subState,__zero_reg__
 1061               	.LVL42:
 1062               	.L51:
 1063               	/* epilogue start */
 1064               	.LBE13:
 1065               	.LBE12:
1277:vec9_io.c     **** 		SetState(DoUpdateIo);
1278:vec9_io.c     **** 	}
1279:vec9_io.c     **** }
 1066               		.loc 1 1279 0
 1067 05f8 CF91      		pop r28
 1068 05fa 0895      		ret
 1069               		.cfi_endproc
 1070               	.LFE22:
 1072               	.global	SetState
 1074               	SetState:
 1075               	.LFB2:
 106:vec9_io.c     **** 	State=newState;
 1076               		.loc 1 106 0
 1077               		.cfi_startproc
 1078               	.LVL43:
 1079               	/* prologue: function */
 1080               	/* frame size = 0 */
 1081               	/* stack size = 0 */
 1082               	.L__stack_usage = 0
 107:vec9_io.c     **** 	subState=SS_0;
 1083               		.loc 1 107 0
 1084 05fc 8093 0000 		sts State,r24
 1085 0600 9093 0000 		sts State+1,r25
 108:vec9_io.c     **** }
 1086               		.loc 1 108 0
 1087 0604 1092 0000 		sts subState,__zero_reg__
 1088 0608 0895      		ret
 1089               		.cfi_endproc
 1090               	.LFE2:
 1092               	.global	__vector_default
 1094               	__vector_default:
 1095               	.LFB3:
 117:vec9_io.c     ****     //  This means a bug happened.  Some interrupt that shouldn't have generated an interrupt went 
 1096               		.loc 1 117 0
 1097               		.cfi_startproc
 1098 060a 1F92      		push r1
 1099               	.LCFI3:
 1100               		.cfi_def_cfa_offset 3
 1101               		.cfi_offset 1, -2
 1102 060c 0F92      		push r0
 1103               	.LCFI4:
 1104               		.cfi_def_cfa_offset 4
 1105               		.cfi_offset 0, -3
 1106 060e 0FB6      		in r0,__SREG__
 1107 0610 0F92      		push r0
 1108 0612 1124      		clr __zero_reg__
 1109               	/* prologue: Signal */
 1110               	/* frame size = 0 */
 1111               	/* stack size = 3 */
 1112               	.L__stack_usage = 3
 124:vec9_io.c     **** }
 1113               		.loc 1 124 0
 1114               	/* #APP */
 1115               	 ;  124 "vec9_io.c" 1
 1116 0614 0C94 0000 		jmp 0000
 1117               	 ;  0 "" 2
 1118               	/* epilogue start */
 125:vec9_io.c     **** 
 1119               		.loc 1 125 0
 1120               	/* #NOAPP */
 1121 0618 0F90      		pop r0
 1122 061a 0FBE      		out __SREG__,r0
 1123 061c 0F90      		pop r0
 1124 061e 1F90      		pop r1
 1125 0620 1895      		reti
 1126               		.cfi_endproc
 1127               	.LFE3:
 1129               	.global	__vector_47
 1131               	__vector_47:
 1132               	.LFB5:
 162:vec9_io.c     **** 	systemTicks++;					// Increment the system ticks.
 1133               		.loc 1 162 0
 1134               		.cfi_startproc
 1135 0622 1F92      		push r1
 1136               	.LCFI5:
 1137               		.cfi_def_cfa_offset 3
 1138               		.cfi_offset 1, -2
 1139 0624 0F92      		push r0
 1140               	.LCFI6:
 1141               		.cfi_def_cfa_offset 4
 1142               		.cfi_offset 0, -3
 1143 0626 0FB6      		in r0,__SREG__
 1144 0628 0F92      		push r0
 1145 062a 1124      		clr __zero_reg__
 1146 062c 8F93      		push r24
 1147               	.LCFI7:
 1148               		.cfi_def_cfa_offset 5
 1149               		.cfi_offset 24, -4
 1150 062e 9F93      		push r25
 1151               	.LCFI8:
 1152               		.cfi_def_cfa_offset 6
 1153               		.cfi_offset 25, -5
 1154               	/* prologue: Signal */
 1155               	/* frame size = 0 */
 1156               	/* stack size = 5 */
 1157               	.L__stack_usage = 5
 163:vec9_io.c     **** }
 1158               		.loc 1 163 0
 1159 0630 8091 0000 		lds r24,systemTicks
 1160 0634 9091 0000 		lds r25,systemTicks+1
 1161 0638 0196      		adiw r24,1
 1162 063a 8093 0000 		sts systemTicks,r24
 1163 063e 9093 0000 		sts systemTicks+1,r25
 1164               	/* epilogue start */
 164:vec9_io.c     **** 
 1165               		.loc 1 164 0
 1166 0642 9F91      		pop r25
 1167 0644 8F91      		pop r24
 1168 0646 0F90      		pop r0
 1169 0648 0FBE      		out __SREG__,r0
 1170 064a 0F90      		pop r0
 1171 064c 1F90      		pop r1
 1172 064e 1895      		reti
 1173               		.cfi_endproc
 1174               	.LFE5:
 1176               	.global	__vector_119
 1178               	__vector_119:
 1179               	.LFB8:
 246:vec9_io.c     **** 	if(bytesInRxFifo<MAX_RX_FIFO_BYTES)
 1180               		.loc 1 246 0
 1181               		.cfi_startproc
 1182 0650 1F92      		push r1
 1183               	.LCFI9:
 1184               		.cfi_def_cfa_offset 3
 1185               		.cfi_offset 1, -2
 1186 0652 0F92      		push r0
 1187               	.LCFI10:
 1188               		.cfi_def_cfa_offset 4
 1189               		.cfi_offset 0, -3
 1190 0654 0FB6      		in r0,__SREG__
 1191 0656 0F92      		push r0
 1192 0658 1124      		clr __zero_reg__
 1193 065a 0BB6      		in r0,__RAMPZ__
 1194 065c 0F92      		push r0
 1195 065e 8F93      		push r24
 1196               	.LCFI11:
 1197               		.cfi_def_cfa_offset 5
 1198               		.cfi_offset 24, -4
 1199 0660 EF93      		push r30
 1200               	.LCFI12:
 1201               		.cfi_def_cfa_offset 6
 1202               		.cfi_offset 30, -5
 1203 0662 FF93      		push r31
 1204               	.LCFI13:
 1205               		.cfi_def_cfa_offset 7
 1206               		.cfi_offset 31, -6
 1207               	/* prologue: Signal */
 1208               	/* frame size = 0 */
 1209               	/* stack size = 7 */
 1210               	.L__stack_usage = 7
 247:vec9_io.c     **** 	{
 1211               		.loc 1 247 0
 1212 0664 8091 0000 		lds r24,bytesInRxFifo
 1213 0668 8034      		cpi r24,lo8(64)
 1214 066a 00F4      		brsh .L197
 249:vec9_io.c     **** 		fifoWritePointer++;							// Move write pointer forward
 1215               		.loc 1 249 0
 1216 066c E091 0000 		lds r30,fifoWritePointer
 1217 0670 F0E0      		ldi r31,0
 1218 0672 8091 A00B 		lds r24,2976
 1219 0676 E050      		subi r30,lo8(-(rxFifo))
 1220 0678 F040      		sbci r31,hi8(-(rxFifo))
 1221 067a 8083      		st Z,r24
 250:vec9_io.c     **** 		if(fifoWritePointer>=MAX_RX_FIFO_BYTES)		// Roll write pointer around end of ring buffer if neede
 1222               		.loc 1 250 0
 1223 067c 8091 0000 		lds r24,fifoWritePointer
 1224 0680 8F5F      		subi r24,lo8(-(1))
 1225 0682 8093 0000 		sts fifoWritePointer,r24
 251:vec9_io.c     **** 		{
 1226               		.loc 1 251 0
 1227 0686 8091 0000 		lds r24,fifoWritePointer
 1228 068a 8034      		cpi r24,lo8(64)
 1229 068c 00F0      		brlo .L198
 253:vec9_io.c     **** 		}
 1230               		.loc 1 253 0
 1231 068e 1092 0000 		sts fifoWritePointer,__zero_reg__
 1232               	.L198:
 255:vec9_io.c     **** 	}
 1233               		.loc 1 255 0
 1234 0692 8091 0000 		lds r24,bytesInRxFifo
 1235 0696 8F5F      		subi r24,lo8(-(1))
 1236 0698 8093 0000 		sts bytesInRxFifo,r24
 1237 069c 00C0      		rjmp .L196
 1238               	.L197:
 259:vec9_io.c     **** 	}
 1239               		.loc 1 259 0
 1240 069e 8091 A00B 		lds r24,2976
 1241 06a2 8093 0000 		sts dump,r24
 1242               	.L196:
 1243               	/* epilogue start */
 261:vec9_io.c     **** 
 1244               		.loc 1 261 0
 1245 06a6 FF91      		pop r31
 1246 06a8 EF91      		pop r30
 1247 06aa 8F91      		pop r24
 1248 06ac 0F90      		pop r0
 1249 06ae 0BBE      		out __RAMPZ__,r0
 1250 06b0 0F90      		pop r0
 1251 06b2 0FBE      		out __SREG__,r0
 1252 06b4 0F90      		pop r0
 1253 06b6 1F90      		pop r1
 1254 06b8 1895      		reti
 1255               		.cfi_endproc
 1256               	.LFE8:
 1258               	.global	GetByteFromRxFifo
 1260               	GetByteFromRxFifo:
 1261               	.LFB10:
 286:vec9_io.c     **** 	unsigned char
 1262               		.loc 1 286 0
 1263               		.cfi_startproc
 1264               	/* prologue: function */
 1265               	/* frame size = 0 */
 1266               	/* stack size = 0 */
 1267               	.L__stack_usage = 0
 291:vec9_io.c     **** 	cli();
 1268               		.loc 1 291 0
 1269 06ba 2FB7      		in r18,__SREG__
 1270               	.LVL44:
 292:vec9_io.c     **** 
 1271               		.loc 1 292 0
 1272               	/* #APP */
 1273               	 ;  292 "vec9_io.c" 1
 1274 06bc F894      		cli
 1275               	 ;  0 "" 2
 294:vec9_io.c     **** 	{
 1276               		.loc 1 294 0
 1277               	/* #NOAPP */
 1278 06be 8091 0000 		lds r24,bytesInRxFifo
 1279 06c2 8823      		tst r24
 1280 06c4 01F0      		breq .L201
 296:vec9_io.c     **** 		fifoReadPointer++;							// Move pointer forward
 1281               		.loc 1 296 0
 1282 06c6 E091 0000 		lds r30,fifoReadPointer
 1283 06ca F0E0      		ldi r31,0
 1284 06cc E050      		subi r30,lo8(-(rxFifo))
 1285 06ce F040      		sbci r31,hi8(-(rxFifo))
 1286 06d0 8081      		ld r24,Z
 1287               	.LVL45:
 297:vec9_io.c     **** 		if(fifoReadPointer>=MAX_RX_FIFO_BYTES)		// Roll pointer around end of ring buffer if needed
 1288               		.loc 1 297 0
 1289 06d2 9091 0000 		lds r25,fifoReadPointer
 1290 06d6 9F5F      		subi r25,lo8(-(1))
 1291 06d8 9093 0000 		sts fifoReadPointer,r25
 298:vec9_io.c     **** 		{
 1292               		.loc 1 298 0
 1293 06dc 9091 0000 		lds r25,fifoReadPointer
 1294 06e0 9034      		cpi r25,lo8(64)
 1295 06e2 00F0      		brlo .L202
 300:vec9_io.c     **** 		}
 1296               		.loc 1 300 0
 1297 06e4 1092 0000 		sts fifoReadPointer,__zero_reg__
 1298               	.L202:
 302:vec9_io.c     **** 
 1299               		.loc 1 302 0
 1300 06e8 9091 0000 		lds r25,bytesInRxFifo
 1301 06ec 9150      		subi r25,lo8(-(-1))
 1302 06ee 9093 0000 		sts bytesInRxFifo,r25
 1303               	.LVL46:
 1304               	.L201:
 309:vec9_io.c     **** 		return(0);		// Should not happen.  If we call this when there are no bytes in the fifo, return 0
 1305               		.loc 1 309 0
 1306 06f2 2FBF      		out __SREG__,r18
 312:vec9_io.c     **** 
 1307               		.loc 1 312 0
 1308 06f4 0895      		ret
 1309               		.cfi_endproc
 1310               	.LFE10:
 1313               	DoUpdateIo:
 1314               	.LFB21:
 919:vec9_io.c     **** 
 1315               		.loc 1 919 0
 1316               		.cfi_startproc
 1317 06f6 0F93      		push r16
 1318               	.LCFI14:
 1319               		.cfi_def_cfa_offset 3
 1320               		.cfi_offset 16, -2
 1321 06f8 1F93      		push r17
 1322               	.LCFI15:
 1323               		.cfi_def_cfa_offset 4
 1324               		.cfi_offset 17, -3
 1325 06fa CF93      		push r28
 1326               	.LCFI16:
 1327               		.cfi_def_cfa_offset 5
 1328               		.cfi_offset 28, -4
 1329 06fc DF93      		push r29
 1330               	.LCFI17:
 1331               		.cfi_def_cfa_offset 6
 1332               		.cfi_offset 29, -5
 1333               	/* prologue: function */
 1334               	/* frame size = 0 */
 1335               	/* stack size = 4 */
 1336               	.L__stack_usage = 4
 922:vec9_io.c     **** 	{
 1337               		.loc 1 922 0
 1338 06fe 8091 0000 		lds r24,newAdcResult
 1339 0702 8130      		cpi r24,lo8(1)
 1340 0704 01F4      		brne .L205
 924:vec9_io.c     **** 	}
 1341               		.loc 1 924 0
 1342 0706 8091 0000 		lds r24,adcResults
 1343 070a 9091 0000 		lds r25,adcResults+1
 1344 070e 33E0      		ldi r19,3
 1345               		1:
 1346 0710 9695      		lsr r25
 1347 0712 8795      		ror r24
 1348 0714 3A95      		dec r19
 1349 0716 01F4      		brne 1b
 1350 0718 8093 0000 		sts analogPitch,r24
 1351               	.L205:
 926:vec9_io.c     **** 	{
 1352               		.loc 1 926 0
 1353 071c 8091 0000 		lds r24,newAdcResult+1
 1354 0720 8130      		cpi r24,lo8(1)
 1355 0722 01F4      		brne .L206
 928:vec9_io.c     **** 	}
 1356               		.loc 1 928 0
 1357 0724 8091 0000 		lds r24,adcResults+2
 1358 0728 9091 0000 		lds r25,adcResults+2+1
 1359 072c 23E0      		ldi r18,3
 1360               		1:
 1361 072e 9695      		lsr r25
 1362 0730 8795      		ror r24
 1363 0732 2A95      		dec r18
 1364 0734 01F4      		brne 1b
 1365 0736 8093 0000 		sts analogRoll,r24
 1366               	.L206:
 1367               	.LVL47:
 1368               	.LBB20:
 1369               	.LBB21:
 839:vec9_io.c     **** 	{
 1370               		.loc 1 839 0
 1371 073a 84E0      		ldi r24,lo8(4)
 1372 073c 0E94 0000 		call CheckTimer
 1373               	.LVL48:
 1374 0740 8111      		cpse r24,__zero_reg__
 841:vec9_io.c     **** 	}
 1375               		.loc 1 841 0
 1376 0742 1092 0000 		sts rxMessageState.3918,__zero_reg__
 1377               	.L207:
 867:vec9_io.c     **** 				break;
 1378               		.loc 1 867 0
 1379 0746 C0E0      		ldi r28,0
 858:vec9_io.c     **** 				break;
 1380               		.loc 1 858 0
 1381 0748 D2E0      		ldi r29,lo8(2)
 853:vec9_io.c     **** 				}
 1382               		.loc 1 853 0
 1383 074a 11E0      		ldi r17,lo8(1)
 862:vec9_io.c     **** 				break;
 1384               		.loc 1 862 0
 1385 074c 03E0      		ldi r16,lo8(3)
 1386               	.LVL49:
 1387               	.L208:
 1388               	.LBB22:
 1389               	.LBB23:
 271:vec9_io.c     **** 	cli();
 1390               		.loc 1 271 0
 1391 074e 9FB7      		in r25,__SREG__
 1392               	.LVL50:
 272:vec9_io.c     **** 
 1393               		.loc 1 272 0
 1394               	/* #APP */
 1395               	 ;  272 "vec9_io.c" 1
 1396 0750 F894      		cli
 1397               	 ;  0 "" 2
 1398               	.LVL51:
 275:vec9_io.c     **** 	{
 1399               		.loc 1 275 0
 1400               	/* #NOAPP */
 1401 0752 8091 0000 		lds r24,bytesInRxFifo
 1402               	.LVL52:
 280:vec9_io.c     **** 	return(retVal);
 1403               		.loc 1 280 0
 1404 0756 9FBF      		out __SREG__,r25
 1405               	.LBE23:
 1406               	.LBE22:
 844:vec9_io.c     **** 	{
 1407               		.loc 1 844 0
 1408 0758 8823      		tst r24
 1409 075a 01F0      		breq .L214
 1410 075c C111      		cpse r28,__zero_reg__
 1411 075e 00C0      		rjmp .L216
 846:vec9_io.c     **** 		byte=GetByteFromRxFifo();											// Inhale it
 1412               		.loc 1 846 0
 1413 0760 67E7      		ldi r22,lo8(119)
 1414 0762 71E0      		ldi r23,lo8(1)
 1415 0764 84E0      		ldi r24,lo8(4)
 1416               	.LVL53:
 1417 0766 0E94 0000 		call SetTimer
 1418               	.LVL54:
 847:vec9_io.c     **** 		switch(rxMessageState)
 1419               		.loc 1 847 0
 1420 076a 0E94 0000 		call GetByteFromRxFifo
 1421               	.LVL55:
 848:vec9_io.c     **** 		{
 1422               		.loc 1 848 0
 1423 076e 9091 0000 		lds r25,rxMessageState.3918
 1424 0772 9130      		cpi r25,lo8(1)
 1425 0774 01F0      		breq .L210
 1426 0776 00F0      		brlo .L211
 1427 0778 9230      		cpi r25,lo8(2)
 1428 077a 01F0      		breq .L212
 1429 077c 9330      		cpi r25,lo8(3)
 1430 077e 01F4      		brne .L208
 865:vec9_io.c     **** 				rxMessageState=0;
 1431               		.loc 1 865 0
 1432 0780 8093 0000 		sts outputByteLow,r24
 866:vec9_io.c     **** 				gotMessage=true;
 1433               		.loc 1 866 0
 1434 0784 1092 0000 		sts rxMessageState.3918,__zero_reg__
 1435               	.LVL56:
 867:vec9_io.c     **** 				break;
 1436               		.loc 1 867 0
 1437 0788 C1E0      		ldi r28,lo8(1)
 1438 078a 00C0      		rjmp .L208
 1439               	.LVL57:
 1440               	.L211:
 851:vec9_io.c     **** 				{
 1441               		.loc 1 851 0
 1442 078c 8234      		cpi r24,lo8(66)
 1443 078e 01F4      		brne .L208
 853:vec9_io.c     **** 				}
 1444               		.loc 1 853 0
 1445 0790 1093 0000 		sts rxMessageState.3918,r17
 1446 0794 00C0      		rjmp .L208
 1447               	.L210:
 857:vec9_io.c     **** 				rxMessageState=2;
 1448               		.loc 1 857 0
 1449 0796 8093 0000 		sts outputByteHigh,r24
 858:vec9_io.c     **** 				break;
 1450               		.loc 1 858 0
 1451 079a D093 0000 		sts rxMessageState.3918,r29
 1452 079e 00C0      		rjmp .L208
 1453               	.L212:
 861:vec9_io.c     **** 				rxMessageState=3;
 1454               		.loc 1 861 0
 1455 07a0 8093 0000 		sts outputByteMiddle,r24
 862:vec9_io.c     **** 				break;
 1456               		.loc 1 862 0
 1457 07a4 0093 0000 		sts rxMessageState.3918,r16
 1458 07a8 00C0      		rjmp .L208
 1459               	.LVL58:
 1460               	.L214:
 872:vec9_io.c     **** //	if(CheckTimer(TIMER_1))
 1461               		.loc 1 872 0
 1462 07aa CC23      		tst r28
 1463 07ac 01F0      		breq .L217
 1464               	.L216:
 875:vec9_io.c     **** 
 1465               		.loc 1 875 0
 1466 07ae 0E94 0000 		call SetOutputs
 1467               	.LVL59:
 879:vec9_io.c     **** 		{
 1468               		.loc 1 879 0
 1469 07b2 8091 0000 		lds r24,txBytesToSend
 1470 07b6 8111      		cpse r24,__zero_reg__
 1471 07b8 00C0      		rjmp .L217
 881:vec9_io.c     **** 			txBuffer[1]=(unsigned char)((keyState>>8)&0xFF);
 1472               		.loc 1 881 0
 1473 07ba 81E4      		ldi r24,lo8(65)
 1474 07bc 8093 0000 		sts txBuffer,r24
 882:vec9_io.c     **** 			txBuffer[2]=(unsigned char)(keyState&0xFF);
 1475               		.loc 1 882 0
 1476 07c0 8091 0000 		lds r24,keyState
 1477 07c4 9091 0000 		lds r25,keyState+1
 1478 07c8 9093 0000 		sts txBuffer+1,r25
 883:vec9_io.c     **** 			txBuffer[3]=0;
 1479               		.loc 1 883 0
 1480 07cc 8093 0000 		sts txBuffer+2,r24
 884:vec9_io.c     **** 			txBuffer[4]=0;
 1481               		.loc 1 884 0
 1482 07d0 1092 0000 		sts txBuffer+3,__zero_reg__
 885:vec9_io.c     **** 			txBuffer[5]=analogRoll;
 1483               		.loc 1 885 0
 1484 07d4 1092 0000 		sts txBuffer+4,__zero_reg__
 886:vec9_io.c     **** 			txBuffer[6]=analogPitch;
 1485               		.loc 1 886 0
 1486 07d8 8091 0000 		lds r24,analogRoll
 1487 07dc 8093 0000 		sts txBuffer+5,r24
 887:vec9_io.c     **** 				
 1488               		.loc 1 887 0
 1489 07e0 8091 0000 		lds r24,analogPitch
 1490 07e4 8093 0000 		sts txBuffer+6,r24
 889:vec9_io.c     **** 			txBufferIndex=0;
 1491               		.loc 1 889 0
 1492 07e8 87E0      		ldi r24,lo8(7)
 1493 07ea 8093 0000 		sts txBytesToSend,r24
 890:vec9_io.c     **** 		}
 1494               		.loc 1 890 0
 1495 07ee 1092 0000 		sts txBufferIndex,__zero_reg__
 1496               	.L217:
 1497               	.LBE21:
 1498               	.LBE20:
 932:vec9_io.c     **** 	{
 1499               		.loc 1 932 0
 1500 07f2 8091 0000 		lds r24,txBytesToSend
 1501 07f6 8823      		tst r24
 1502 07f8 01F0      		breq .L204
 1503               	.LBB24:
 1504               	.LBB25:
 901:vec9_io.c     **** 	{
 1505               		.loc 1 901 0
 1506 07fa 8091 0000 		lds r24,txBytesToSend
 1507 07fe 8823      		tst r24
 1508 0800 01F0      		breq .L204
 903:vec9_io.c     **** 		{
 1509               		.loc 1 903 0
 1510 0802 0E94 0000 		call UartTxBufferReady
 1511               	.LVL60:
 1512 0806 8823      		tst r24
 1513 0808 01F0      		breq .L204
 905:vec9_io.c     **** 			txBytesToSend--;
 1514               		.loc 1 905 0
 1515 080a E091 0000 		lds r30,txBufferIndex
 1516 080e 81E0      		ldi r24,lo8(1)
 1517 0810 8E0F      		add r24,r30
 1518 0812 8093 0000 		sts txBufferIndex,r24
 1519 0816 F0E0      		ldi r31,0
 1520 0818 E050      		subi r30,lo8(-(txBuffer))
 1521 081a F040      		sbci r31,hi8(-(txBuffer))
 1522 081c 8081      		ld r24,Z
 1523 081e 0E94 0000 		call UartSendByte
 1524               	.LVL61:
 906:vec9_io.c     **** 		}
 1525               		.loc 1 906 0
 1526 0822 8091 0000 		lds r24,txBytesToSend
 1527 0826 8150      		subi r24,lo8(-(-1))
 1528 0828 8093 0000 		sts txBytesToSend,r24
 1529               	.L204:
 1530               	/* epilogue start */
 1531               	.LBE25:
 1532               	.LBE24:
 936:vec9_io.c     **** 
 1533               		.loc 1 936 0
 1534 082c DF91      		pop r29
 1535 082e CF91      		pop r28
 1536               	.LVL62:
 1537 0830 1F91      		pop r17
 1538 0832 0F91      		pop r16
 1539 0834 0895      		ret
 1540               		.cfi_endproc
 1541               	.LFE21:
 1543               	.global	__vector_64
 1545               	__vector_64:
 1546               	.LFB18:
 823:vec9_io.c     **** }
 1547               		.loc 1 823 0
 1548               		.cfi_startproc
 1549 0836 1F92      		push r1
 1550               	.LCFI18:
 1551               		.cfi_def_cfa_offset 3
 1552               		.cfi_offset 1, -2
 1553 0838 0F92      		push r0
 1554               	.LCFI19:
 1555               		.cfi_def_cfa_offset 4
 1556               		.cfi_offset 0, -3
 1557 083a 0FB6      		in r0,__SREG__
 1558 083c 0F92      		push r0
 1559 083e 1124      		clr __zero_reg__
 1560               	/* prologue: Signal */
 1561               	/* frame size = 0 */
 1562               	/* stack size = 3 */
 1563               	.L__stack_usage = 3
 1564               	/* epilogue start */
 824:vec9_io.c     **** 
 1565               		.loc 1 824 0
 1566 0840 0F90      		pop r0
 1567 0842 0FBE      		out __SREG__,r0
 1568 0844 0F90      		pop r0
 1569 0846 1F90      		pop r1
 1570 0848 1895      		reti
 1571               		.cfi_endproc
 1572               	.LFE18:
 1574               		.section	.rodata.str1.1,"aMS",@progbits,1
 1575               	.LC0:
 1576 0000 4170 7220 		.string	"Apr 26 2016"
 1576      3236 2032 
 1576      3031 3600 
 1577               	.LC1:
 1578 000c 0A2A 2A50 		.string	"\n**People's Glorious VEC9 Cockpit Controller**\nTMB\n%s\n"
 1578      656F 706C 
 1578      6527 7320 
 1578      476C 6F72 
 1578      696F 7573 
 1579               		.section	.text.startup,"ax",@progbits
 1580               	.global	main
 1582               	main:
 1583               	.LFB23:
1280:vec9_io.c     **** 
1281:vec9_io.c     **** //-----------------------------------------------------------------------
1282:vec9_io.c     **** //-----------------------------------------------------------------------
1283:vec9_io.c     **** // Program main loop:
1284:vec9_io.c     **** //-----------------------------------------------------------------------
1285:vec9_io.c     **** //-----------------------------------------------------------------------
1286:vec9_io.c     **** 
1287:vec9_io.c     **** int main(void)
1288:vec9_io.c     **** // Application main loop.
1289:vec9_io.c     **** {
 1584               		.loc 1 1289 0
 1585               		.cfi_startproc
 1586               	/* prologue: function */
 1587               	/* frame size = 0 */
 1588               	/* stack size = 0 */
 1589               	.L__stack_usage = 0
1290:vec9_io.c     **** 	cli();			// No interrupts until we're ready.
 1590               		.loc 1 1290 0
 1591               	/* #APP */
 1592               	 ;  1290 "vec9_io.c" 1
 1593 0000 F894      		cli
 1594               	 ;  0 "" 2
 1595               	/* #NOAPP */
 1596               	.LBB42:
 1597               	.LBB43:
 612:vec9_io.c     **** 	PORTC.DIRSET=0x38;		
 1598               		.loc 1 612 0
 1599 0002 88E3      		ldi r24,lo8(56)
 1600 0004 8093 4606 		sts 1606,r24
 613:vec9_io.c     **** 
 1601               		.loc 1 613 0
 1602 0008 8093 4106 		sts 1601,r24
 615:vec9_io.c     **** 	PORTD.DIRSET=0xFF;		
 1603               		.loc 1 615 0
 1604 000c 8FEF      		ldi r24,lo8(-1)
 1605 000e 8093 6506 		sts 1637,r24
 616:vec9_io.c     **** 
 1606               		.loc 1 616 0
 1607 0012 8093 6106 		sts 1633,r24
 618:vec9_io.c     **** 	PORTE.DIRSET=0xFF;		
 1608               		.loc 1 618 0
 1609 0016 8093 8606 		sts 1670,r24
 619:vec9_io.c     **** 
 1610               		.loc 1 619 0
 1611 001a 8093 8106 		sts 1665,r24
 621:vec9_io.c     **** 	PORTF.DIRSET=0x03;		
 1612               		.loc 1 621 0
 1613 001e 83E0      		ldi r24,lo8(3)
 1614 0020 8093 A606 		sts 1702,r24
 622:vec9_io.c     **** }
 1615               		.loc 1 622 0
 1616 0024 8093 A106 		sts 1697,r24
 1617               	.LBE43:
 1618               	.LBE42:
1291:vec9_io.c     **** 
1292:vec9_io.c     **** 	InitOutputs();			// Turn off all outputs
1293:vec9_io.c     **** 	
1294:vec9_io.c     **** 	// Xmega parts start running an internal clock at 2MHZ -- we change that in software.
1295:vec9_io.c     **** 	// This board has a 20MHz silicon oscillator hooked up to the MCU which we use as the CPU clock
1296:vec9_io.c     **** 
1297:vec9_io.c     **** 	OSC.XOSCCTRL=OSC_XOSCSEL_EXTCLK_gc;				// No crystal oscillator, set up for external clock in (thi
 1619               		.loc 1 1297 0
 1620 0028 1092 5200 		sts 82,__zero_reg__
1298:vec9_io.c     **** 	OSC.PLLCTRL=(0b00<<OSC_PLLSRC_gp)|(0<<OSC_PLLFAC_gp);	// no PLL
 1621               		.loc 1 1298 0
 1622 002c 1092 5500 		sts 85,__zero_reg__
1299:vec9_io.c     **** 	OSC.DFLLCTRL=0;						// no calibration
 1623               		.loc 1 1299 0
 1624 0030 1092 5600 		sts 86,__zero_reg__
1300:vec9_io.c     **** 	OSC.XOSCFAIL=0;						// no failure monitoring
 1625               		.loc 1 1300 0
 1626 0034 1092 5300 		sts 83,__zero_reg__
1301:vec9_io.c     **** 
1302:vec9_io.c     **** 	OSC.CTRL=(0<<OSC_PLLEN_bp)|(1<<OSC_XOSCEN_bp)|(0<<OSC_RC32KEN_bp)|(0<<OSC_RC32MEN_bp)|(1<<OSC_RC2M
 1627               		.loc 1 1302 0
 1628 0038 89E0      		ldi r24,lo8(9)
 1629 003a 8093 5000 		sts 80,r24
 1630               	.L233:
1303:vec9_io.c     **** 
1304:vec9_io.c     **** 	while(!(OSC.STATUS&(1<<OSC_XOSCRDY_bp)))		// sit here until external clock is alive
 1631               		.loc 1 1304 0 discriminator 1
 1632 003e 8091 5100 		lds r24,81
 1633 0042 83FF      		sbrs r24,3
 1634 0044 00C0      		rjmp .L233
1305:vec9_io.c     **** 		;
1306:vec9_io.c     **** 
1307:vec9_io.c     **** 	CCPWrite(&CLK.PSCTRL,0);						//	No prescaling
 1635               		.loc 1 1307 0
 1636 0046 60E0      		ldi r22,0
 1637 0048 81E4      		ldi r24,lo8(65)
 1638 004a 90E0      		ldi r25,0
 1639 004c 0E94 0000 		call CCPWrite
 1640               	.LVL63:
1308:vec9_io.c     **** 	CCPWrite(&CLK.CTRL,CLK_SCLKSEL_XOSC_gc);		//	Set ext oscillator as the clock source
 1641               		.loc 1 1308 0
 1642 0050 63E0      		ldi r22,lo8(3)
 1643 0052 80E4      		ldi r24,lo8(64)
 1644 0054 90E0      		ldi r25,0
 1645 0056 0E94 0000 		call CCPWrite
 1646               	.LVL64:
1309:vec9_io.c     **** 	CLK.RTCCTRL=CLK_RTCSRC_RCOSC_gc|0;				// select internal 32.748KHz RC, but leave it disabled
 1647               		.loc 1 1309 0
 1648 005a 84E0      		ldi r24,lo8(4)
 1649 005c 8093 4300 		sts 67,r24
1310:vec9_io.c     **** 
1311:vec9_io.c     **** 	CCPWrite(&OSC.XOSCFAIL,OSC_XOSCFDEN_bm);		//  Enable failure detection on internal oscillator (res
 1650               		.loc 1 1311 0
 1651 0060 61E0      		ldi r22,lo8(1)
 1652 0062 83E5      		ldi r24,lo8(83)
 1653 0064 90E0      		ldi r25,0
 1654 0066 0E94 0000 		call CCPWrite
 1655               	.LVL65:
1312:vec9_io.c     **** 	OSC.CTRL&=~(1<<OSC_RC2MEN_bp);					// turn off 2MHz clock now that we're running from the PLL/exte
 1656               		.loc 1 1312 0
 1657 006a 8091 5000 		lds r24,80
 1658 006e 8E7F      		andi r24,lo8(-2)
 1659 0070 8093 5000 		sts 80,r24
1313:vec9_io.c     **** 
1314:vec9_io.c     **** 	// Ports and INIT
1315:vec9_io.c     **** 
1316:vec9_io.c     **** //	PR.PRGEN=0x1F;									// Power off AES, EBI, RTC, event system, and DMA
1317:vec9_io.c     **** //  @@@ power off that stuff once you're sure you aren't using it.
1318:vec9_io.c     **** //  Power off the port peripherals too.
1319:vec9_io.c     **** 
1320:vec9_io.c     **** 	CCPWrite(&MCU.MCUCR,MCU_JTAGD_bm);				//  Disable JTAG (screws up PORTB)
 1660               		.loc 1 1320 0
 1661 0074 61E0      		ldi r22,lo8(1)
 1662 0076 86E9      		ldi r24,lo8(-106)
 1663 0078 90E0      		ldi r25,0
 1664 007a 0E94 0000 		call CCPWrite
 1665               	.LVL66:
1321:vec9_io.c     **** 
1322:vec9_io.c     **** 	InitUart();
 1666               		.loc 1 1322 0
 1667 007e 0E94 0000 		call InitUart
 1668               	.LVL67:
 1669               	.LBB44:
 1670               	.LBB45:
 319:vec9_io.c     **** 	cli();
 1671               		.loc 1 319 0
 1672 0082 8FB7      		in r24,__SREG__
 1673               	.LVL68:
 320:vec9_io.c     **** 
 1674               		.loc 1 320 0
 1675               	/* #APP */
 1676               	 ;  320 "vec9_io.c" 1
 1677 0084 F894      		cli
 1678               	 ;  0 "" 2
 322:vec9_io.c     **** 	fifoWritePointer=0;
 1679               		.loc 1 322 0
 1680               	/* #NOAPP */
 1681 0086 1092 0000 		sts bytesInRxFifo,__zero_reg__
 323:vec9_io.c     **** 	fifoReadPointer=0;
 1682               		.loc 1 323 0
 1683 008a 1092 0000 		sts fifoWritePointer,__zero_reg__
 324:vec9_io.c     **** 	txBufferIndex=0;
 1684               		.loc 1 324 0
 1685 008e 1092 0000 		sts fifoReadPointer,__zero_reg__
 325:vec9_io.c     **** 	txBytesToSend=0;
 1686               		.loc 1 325 0
 1687 0092 1092 0000 		sts txBufferIndex,__zero_reg__
 326:vec9_io.c     **** 	SERIAL_USART.CTRLA=USART_RXCINTLVL_MED_gc;	// Interrupts enabled, medium priority
 1688               		.loc 1 326 0
 1689 0096 1092 0000 		sts txBytesToSend,__zero_reg__
 327:vec9_io.c     **** 
 1690               		.loc 1 327 0
 1691 009a 90E2      		ldi r25,lo8(32)
 1692 009c 9093 A30B 		sts 2979,r25
 329:vec9_io.c     **** }
 1693               		.loc 1 329 0
 1694 00a0 8FBF      		out __SREG__,r24
 1695               	.LBE45:
 1696               	.LBE44:
 1697               	.LBB46:
 1698               	.LBB47:
 488:vec9_io.c     **** 	PORTA.DIRCLR=0x0F;										// PORTA analog inputs to inputs
 1699               		.loc 1 488 0
 1700 00a2 8091 7100 		lds r24,113
 1701               	.LVL69:
 1702 00a6 8D7F      		andi r24,lo8(-3)
 1703 00a8 8093 7100 		sts 113,r24
 1704               	.LVL70:
 489:vec9_io.c     **** 
 1705               		.loc 1 489 0
 1706 00ac 8FE0      		ldi r24,lo8(15)
 1707 00ae 8093 0206 		sts 1538,r24
 492:vec9_io.c     **** 	ADCA.REFCTRL=ADC_REFSEL_AREFA_gc;						// External reference A, bandgap and temp disabled
 1708               		.loc 1 492 0
 1709 00b2 80E1      		ldi r24,lo8(16)
 1710 00b4 8093 0102 		sts 513,r24
 493:vec9_io.c     **** //	ADCA.PRESCALER=ADC_PRESCALER_DIV256_gc;					// 16MHz divided by 256 = 62.5kHz  (see notes)	-- OG
 1711               		.loc 1 493 0
 1712 00b8 9093 0202 		sts 514,r25
 496:vec9_io.c     **** 
 1713               		.loc 1 496 0
 1714 00bc C7E0      		ldi r28,lo8(7)
 1715 00be C093 0402 		sts 516,r28
 498:vec9_io.c     **** 	ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN2_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN2 (PA2), Neg
 1716               		.loc 1 498 0
 1717 00c2 82E0      		ldi r24,lo8(2)
 1718 00c4 8093 2002 		sts 544,r24
 499:vec9_io.c     **** 	ADCA.CH0.INTCTRL=0;												// No interrupts
 1719               		.loc 1 499 0
 1720 00c8 83E1      		ldi r24,lo8(19)
 1721 00ca 8093 2102 		sts 545,r24
 500:vec9_io.c     **** 
 1722               		.loc 1 500 0
 1723 00ce 1092 2202 		sts 546,__zero_reg__
 502:vec9_io.c     **** 
 1724               		.loc 1 502 0
 1725 00d2 D1E0      		ldi r29,lo8(1)
 1726 00d4 D093 0002 		sts 512,r29
 506:vec9_io.c     **** 	adcSampleCount=0;	// Zero oversample/average counter
 1727               		.loc 1 506 0
 1728 00d8 1092 0000 		sts adcResultTemp,__zero_reg__
 1729 00dc 1092 0000 		sts adcResultTemp+1,__zero_reg__
 1730 00e0 1092 0000 		sts adcResultTemp+2,__zero_reg__
 1731 00e4 1092 0000 		sts adcResultTemp+3,__zero_reg__
 507:vec9_io.c     **** 
 1732               		.loc 1 507 0
 1733 00e8 1092 0000 		sts adcSampleCount,__zero_reg__
 1734               	.LVL71:
 511:vec9_io.c     **** 		newAdcResult[i]=false;
 1735               		.loc 1 511 0
 1736 00ec 1092 0000 		sts adcResults,__zero_reg__
 1737 00f0 1092 0000 		sts adcResults+1,__zero_reg__
 512:vec9_io.c     **** 	}
 1738               		.loc 1 512 0
 1739 00f4 1092 0000 		sts newAdcResult,__zero_reg__
 1740               	.LVL72:
 511:vec9_io.c     **** 		newAdcResult[i]=false;
 1741               		.loc 1 511 0
 1742 00f8 1092 0000 		sts adcResults+2,__zero_reg__
 1743 00fc 1092 0000 		sts adcResults+2+1,__zero_reg__
 512:vec9_io.c     **** 	}
 1744               		.loc 1 512 0
 1745 0100 1092 0000 		sts newAdcResult+1,__zero_reg__
 1746               	.LVL73:
 515:vec9_io.c     **** 
 1747               		.loc 1 515 0
 1748 0104 1092 0000 		sts currentAdcSource,__zero_reg__
 517:vec9_io.c     **** 
 1749               		.loc 1 517 0
 1750 0108 8091 2002 		lds r24,544
 1751 010c 8068      		ori r24,lo8(-128)
 1752 010e 8093 2002 		sts 544,r24
 1753               	.LBE47:
 1754               	.LBE46:
 1755               	.LBB48:
 1756               	.LBB49:
 351:vec9_io.c     **** 	PORTA.PIN5CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1757               		.loc 1 351 0
 1758 0112 80EE      		ldi r24,lo8(-32)
 1759 0114 8093 0206 		sts 1538,r24
 352:vec9_io.c     **** 	PORTA.PIN6CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1760               		.loc 1 352 0
 1761 0118 88E5      		ldi r24,lo8(88)
 1762 011a 8093 1506 		sts 1557,r24
 353:vec9_io.c     **** 	PORTA.PIN7CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1763               		.loc 1 353 0
 1764 011e 8093 1606 		sts 1558,r24
 354:vec9_io.c     **** 
 1765               		.loc 1 354 0
 1766 0122 8093 1706 		sts 1559,r24
 356:vec9_io.c     **** 	PORTCFG.MPCMASK=0xFF;								// Configure these pins on this port next time we write the config re
 1767               		.loc 1 356 0
 1768 0126 1FEF      		ldi r17,lo8(-1)
 1769 0128 1093 2206 		sts 1570,r17
 357:vec9_io.c     **** 	PORTB.PIN0CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1770               		.loc 1 357 0
 1771 012c 1093 B000 		sts 176,r17
 358:vec9_io.c     **** 
 1772               		.loc 1 358 0
 1773 0130 8093 3006 		sts 1584,r24
 360:vec9_io.c     **** 	PORTC.PIN0CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1774               		.loc 1 360 0
 1775 0134 C093 4206 		sts 1602,r28
 361:vec9_io.c     **** 	PORTC.PIN1CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1776               		.loc 1 361 0
 1777 0138 8093 5006 		sts 1616,r24
 362:vec9_io.c     **** 	PORTC.PIN2CTRL=PORT_INVEN_bm|PORT_OPC_PULLUP_gc;	// Set them to be pulled up and inverted
 1778               		.loc 1 362 0
 1779 013c 8093 5106 		sts 1617,r24
 363:vec9_io.c     **** 
 1780               		.loc 1 363 0
 1781 0140 8093 5206 		sts 1618,r24
 365:vec9_io.c     **** 	newKeys=0;		// No keys new
 1782               		.loc 1 365 0
 1783 0144 1092 0000 		sts keyState,__zero_reg__
 1784 0148 1092 0000 		sts keyState+1,__zero_reg__
 366:vec9_io.c     **** 
 1785               		.loc 1 366 0
 1786 014c 1092 0000 		sts newKeys,__zero_reg__
 1787 0150 1092 0000 		sts newKeys+1,__zero_reg__
 368:vec9_io.c     **** }
 1788               		.loc 1 368 0
 1789 0154 6EE2      		ldi r22,lo8(46)
 1790 0156 70E0      		ldi r23,0
 1791 0158 83E0      		ldi r24,lo8(3)
 1792 015a 0E94 0000 		call SetTimer
 1793               	.LVL74:
 1794               	.LBE49:
 1795               	.LBE48:
 1796               	.LBB50:
 1797               	.LBB51:
 138:vec9_io.c     **** 
 1798               		.loc 1 138 0
 1799 015e 1092 0000 		sts systemTicks,__zero_reg__
 1800 0162 1092 0000 		sts systemTicks+1,__zero_reg__
 140:vec9_io.c     **** 
 1801               		.loc 1 140 0
 1802 0166 8091 7500 		lds r24,117
 1803 016a 8E7F      		andi r24,lo8(-2)
 1804 016c 8093 7500 		sts 117,r24
 142:vec9_io.c     **** 	TCE0.CNT=0;						// Set Count Value to 0.
 1805               		.loc 1 142 0
 1806 0170 1092 280A 		sts 2600,__zero_reg__
 1807 0174 1092 290A 		sts 2600+1,__zero_reg__
 143:vec9_io.c     **** 	TCE0.PER=(F_CPU/SECOND);		// Set period for this timer (max count)
 1808               		.loc 1 143 0
 1809 0178 1092 200A 		sts 2592,__zero_reg__
 1810 017c 1092 210A 		sts 2592+1,__zero_reg__
 144:vec9_io.c     **** 
 1811               		.loc 1 144 0
 1812 0180 8AE0      		ldi r24,lo8(10)
 1813 0182 9AE1      		ldi r25,lo8(26)
 1814 0184 8093 260A 		sts 2598,r24
 1815 0188 9093 270A 		sts 2598+1,r25
 146:vec9_io.c     **** 
 1816               		.loc 1 146 0
 1817 018c 1092 010A 		sts 2561,__zero_reg__
 148:vec9_io.c     **** //	TCE0.INTCTRLA=TC_OVFINTLVL_HI_gc;		// Set wdt overflow interrupt (high priority)
 1818               		.loc 1 148 0
 1819 0190 1093 0C0A 		sts 2572,r17
 150:vec9_io.c     **** 	TCE0.INTCTRLB=0;						// No CC ints
 1820               		.loc 1 150 0
 1821 0194 D093 060A 		sts 2566,r29
 151:vec9_io.c     **** 	TCE0.CTRLA=TC_CLKSEL_DIV1_gc;			// Start the timer with a clock division of 1.
 1822               		.loc 1 151 0
 1823 0198 1092 070A 		sts 2567,__zero_reg__
 152:vec9_io.c     **** }
 1824               		.loc 1 152 0
 1825 019c D093 000A 		sts 2560,r29
 1826               	.LBE51:
 1827               	.LBE50:
1323:vec9_io.c     **** 	InitSerialFifos();
1324:vec9_io.c     **** //	InitSpi();
1325:vec9_io.c     **** 	InitAdc();
1326:vec9_io.c     **** 	InitSwitches();
1327:vec9_io.c     **** 	InitSoftclock();
1328:vec9_io.c     **** 	fdevopen(UartPutChar, NULL);	// Associate stdout with out putchar routine (enable printf)  --- Thi
 1828               		.loc 1 1328 0
 1829 01a0 60E0      		ldi r22,0
 1830 01a2 70E0      		ldi r23,0
 1831 01a4 80E0      		ldi r24,lo8(gs(UartPutChar))
 1832 01a6 90E0      		ldi r25,hi8(gs(UartPutChar))
 1833 01a8 0E94 0000 		call fdevopen
 1834               	.LVL75:
1329:vec9_io.c     **** 
1330:vec9_io.c     **** 	PMIC.CTRL=PMIC_HILVLEN_bm|PMIC_MEDLVLEN_bm|PMIC_LOLVLEN_bm;		// Enable all interrupt levels
 1835               		.loc 1 1330 0
 1836 01ac C093 A200 		sts 162,r28
1331:vec9_io.c     **** 	sei();															// Global interrupt enable
 1837               		.loc 1 1331 0
 1838               	/* #APP */
 1839               	 ;  1331 "vec9_io.c" 1
 1840 01b0 7894      		sei
 1841               	 ;  0 "" 2
1332:vec9_io.c     **** 
1333:vec9_io.c     **** 	RST.STATUS=0x3F;				// Clear reset cause flags	
 1842               		.loc 1 1333 0
 1843               	/* #NOAPP */
 1844 01b2 8FE3      		ldi r24,lo8(63)
 1845 01b4 8093 7800 		sts 120,r24
1334:vec9_io.c     **** 	
1335:vec9_io.c     **** 	printf("\n**People's Glorious VEC9 Cockpit Controller**\nTMB\n%s\n",BUILD_DATE);
 1846               		.loc 1 1335 0
 1847 01b8 80E0      		ldi r24,lo8(.LC0)
 1848 01ba 90E0      		ldi r25,hi8(.LC0)
 1849 01bc 9F93      		push r25
 1850               	.LCFI20:
 1851               		.cfi_def_cfa_offset 3
 1852 01be 8F93      		push r24
 1853               	.LCFI21:
 1854               		.cfi_def_cfa_offset 4
 1855 01c0 80E0      		ldi r24,lo8(.LC1)
 1856 01c2 90E0      		ldi r25,hi8(.LC1)
 1857 01c4 9F93      		push r25
 1858               	.LCFI22:
 1859               		.cfi_def_cfa_offset 5
 1860 01c6 8F93      		push r24
 1861               	.LCFI23:
 1862               		.cfi_def_cfa_offset 6
 1863 01c8 0E94 0000 		call printf
 1864               	.LVL76:
 1865               	.LBB52:
 1866               	.LBB53:
 107:vec9_io.c     **** 	subState=SS_0;
 1867               		.loc 1 107 0
 1868 01cc 80E0      		ldi r24,lo8(gs(DoStartupTest))
 1869 01ce 90E0      		ldi r25,hi8(gs(DoStartupTest))
 1870 01d0 8093 0000 		sts State,r24
 1871 01d4 9093 0000 		sts State+1,r25
 108:vec9_io.c     **** }
 1872               		.loc 1 108 0
 1873 01d8 1092 0000 		sts subState,__zero_reg__
 1874 01dc 0F90      		pop __tmp_reg__
 1875 01de 0F90      		pop __tmp_reg__
 1876 01e0 0F90      		pop __tmp_reg__
 1877 01e2 0F90      		pop __tmp_reg__
 1878               	.LCFI24:
 1879               		.cfi_def_cfa_offset 2
 1880               	.LBE53:
 1881               	.LBE52:
 1882               	.LBB54:
 1883               	.LBB55:
 561:vec9_io.c     **** 				adcResultTemp=0;						// Clear temp register
 1884               		.loc 1 561 0
 1885 01e4 14E0      		ldi r17,lo8(4)
 573:vec9_io.c     **** 					ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN2_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN2 (PA2),
 1886               		.loc 1 573 0
 1887 01e6 C2E0      		ldi r28,lo8(2)
 574:vec9_io.c     **** 					break;
 1888               		.loc 1 574 0
 1889 01e8 03E1      		ldi r16,lo8(19)
 579:vec9_io.c     **** 					break;
 1890               		.loc 1 579 0
 1891 01ea 7BE0      		ldi r23,lo8(11)
 1892 01ec F72E      		mov r15,r23
 1893               	.L245:
 1894               	.LVL77:
 534:vec9_io.c     **** 	}
 1895               		.loc 1 534 0 discriminator 1
 1896 01ee 1092 0000 		sts newAdcResult,__zero_reg__
 1897               	.LVL78:
 1898 01f2 1092 0000 		sts newAdcResult+1,__zero_reg__
 1899               	.LVL79:
 537:vec9_io.c     **** 	{
 1900               		.loc 1 537 0 discriminator 1
 1901 01f6 8091 2302 		lds r24,547
 1902 01fa 80FF      		sbrs r24,0
 1903 01fc 00C0      		rjmp .L234
 539:vec9_io.c     **** 
 1904               		.loc 1 539 0
 1905 01fe 8091 1002 		lds r24,528
 1906 0202 9091 1102 		lds r25,528+1
 1907               	.LVL80:
 541:vec9_io.c     **** 		{
 1908               		.loc 1 541 0
 1909 0206 2091 0000 		lds r18,tossCounter.3890
 1910 020a 2223      		tst r18
 1911 020c 01F0      		breq .L235
 543:vec9_io.c     **** 		}
 1912               		.loc 1 543 0
 1913 020e 2150      		subi r18,lo8(-(-1))
 1914 0210 2093 0000 		sts tossCounter.3890,r18
 1915 0214 00C0      		rjmp .L234
 1916               	.L235:
 1917               	.LVL81:
 1918 0216 97FF      		sbrs r25,7
 1919 0218 00C0      		rjmp .L236
 1920 021a 80E0      		ldi r24,0
 1921 021c 90E0      		ldi r25,0
 1922               	.LVL82:
 1923               	.L236:
 552:vec9_io.c     **** 			adcSampleCount++;			// One more sample gathered
 1924               		.loc 1 552 0
 1925 021e 092E      		mov __tmp_reg__,r25
 1926 0220 000C      		lsl r0
 1927 0222 AA0B      		sbc r26,r26
 1928 0224 BB0B      		sbc r27,r27
 1929 0226 4091 0000 		lds r20,adcResultTemp
 1930 022a 5091 0000 		lds r21,adcResultTemp+1
 1931 022e 6091 0000 		lds r22,adcResultTemp+2
 1932 0232 7091 0000 		lds r23,adcResultTemp+3
 1933 0236 840F      		add r24,r20
 1934 0238 951F      		adc r25,r21
 1935 023a A61F      		adc r26,r22
 1936 023c B71F      		adc r27,r23
 1937 023e 8093 0000 		sts adcResultTemp,r24
 1938 0242 9093 0000 		sts adcResultTemp+1,r25
 1939 0246 A093 0000 		sts adcResultTemp+2,r26
 1940 024a B093 0000 		sts adcResultTemp+3,r27
 553:vec9_io.c     **** 
 1941               		.loc 1 553 0
 1942 024e 2091 0000 		lds r18,adcSampleCount
 1943 0252 2F5F      		subi r18,lo8(-(1))
 1944 0254 2093 0000 		sts adcSampleCount,r18
 555:vec9_io.c     **** 			{
 1945               		.loc 1 555 0
 1946 0258 2830      		cpi r18,lo8(8)
 1947 025a 00F0      		brlo .L237
 557:vec9_io.c     **** 				newAdcResult[currentAdcSource]=true;								// Let program know we have a new ADC reading
 1948               		.loc 1 557 0
 1949 025c 4091 0000 		lds r20,currentAdcSource
 1950 0260 242F      		mov r18,r20
 1951 0262 30E0      		ldi r19,0
 1952 0264 F901      		movw r30,r18
 1953 0266 EE0F      		lsl r30
 1954 0268 FF1F      		rol r31
 1955 026a E050      		subi r30,lo8(-(adcResults))
 1956 026c F040      		sbci r31,hi8(-(adcResults))
 1957 026e 63E0      		ldi r22,3
 1958               		1:
 1959 0270 B695      		lsr r27
 1960 0272 A795      		ror r26
 1961 0274 9795      		ror r25
 1962 0276 8795      		ror r24
 1963 0278 6A95      		dec r22
 1964 027a 01F4      		brne 1b
 1965 027c 8083      		st Z,r24
 1966 027e 9183      		std Z+1,r25
 558:vec9_io.c     **** 
 1967               		.loc 1 558 0
 1968 0280 F901      		movw r30,r18
 1969 0282 E050      		subi r30,lo8(-(newAdcResult))
 1970 0284 F040      		sbci r31,hi8(-(newAdcResult))
 1971 0286 D083      		st Z,r29
 560:vec9_io.c     **** 				tossCounter=SAMPLES_TO_TOSS;			// Ignore initial samples after switching the mux
 1972               		.loc 1 560 0
 1973 0288 1092 0000 		sts adcSampleCount,__zero_reg__
 561:vec9_io.c     **** 				adcResultTemp=0;						// Clear temp register
 1974               		.loc 1 561 0
 1975 028c 1093 0000 		sts tossCounter.3890,r17
 562:vec9_io.c     **** 
 1976               		.loc 1 562 0
 1977 0290 1092 0000 		sts adcResultTemp,__zero_reg__
 1978 0294 1092 0000 		sts adcResultTemp+1,__zero_reg__
 1979 0298 1092 0000 		sts adcResultTemp+2,__zero_reg__
 1980 029c 1092 0000 		sts adcResultTemp+3,__zero_reg__
 564:vec9_io.c     **** 				if(currentAdcSource>=NUM_ADC)			// Roll it around
 1981               		.loc 1 564 0
 1982 02a0 81E0      		ldi r24,lo8(1)
 1983 02a2 840F      		add r24,r20
 565:vec9_io.c     **** 				{
 1984               		.loc 1 565 0
 1985 02a4 8230      		cpi r24,lo8(2)
 1986 02a6 00F4      		brsh .L238
 564:vec9_io.c     **** 				if(currentAdcSource>=NUM_ADC)			// Roll it around
 1987               		.loc 1 564 0
 1988 02a8 8093 0000 		sts currentAdcSource,r24
 1989 02ac 00C0      		rjmp .L239
 1990               	.L238:
 567:vec9_io.c     **** 				}
 1991               		.loc 1 567 0
 1992 02ae 1092 0000 		sts currentAdcSource,__zero_reg__
 1993               	.L239:
 570:vec9_io.c     **** 				{
 1994               		.loc 1 570 0
 1995 02b2 8091 0000 		lds r24,currentAdcSource
 1996 02b6 8823      		tst r24
 1997 02b8 01F0      		breq .L240
 1998 02ba 8130      		cpi r24,lo8(1)
 1999 02bc 01F4      		brne .L237
 578:vec9_io.c     **** 					ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN1_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN1 (PA1),
 2000               		.loc 1 578 0
 2001 02be C093 2002 		sts 544,r28
 579:vec9_io.c     **** 					break;
 2002               		.loc 1 579 0
 2003 02c2 F092 2102 		sts 545,r15
 2004 02c6 00C0      		rjmp .L237
 2005               	.L240:
 573:vec9_io.c     **** 					ADCA.CH0.MUXCTRL=ADC_CH_MUXPOS_PIN2_gc|ADC_CH_MUXNEG_PIN3_gc;	// Positive input is PIN2 (PA2),
 2006               		.loc 1 573 0
 2007 02c8 C093 2002 		sts 544,r28
 574:vec9_io.c     **** 					break;
 2008               		.loc 1 574 0
 2009 02cc 0093 2102 		sts 545,r16
 2010               	.L237:
 589:vec9_io.c     **** 			ADCA.CH0.CTRL|=ADC_CH_START_bm; 	// Start conversion on channel 0
 2011               		.loc 1 589 0
 2012 02d0 8091 2302 		lds r24,547
 2013 02d4 8160      		ori r24,lo8(1)
 2014 02d6 8093 2302 		sts 547,r24
 590:vec9_io.c     **** 		}
 2015               		.loc 1 590 0
 2016 02da 8091 2002 		lds r24,544
 2017 02de 8068      		ori r24,lo8(-128)
 2018 02e0 8093 2002 		sts 544,r24
 2019               	.L234:
 2020               	.LBE55:
 2021               	.LBE54:
 2022               	.LBB56:
 2023               	.LBB57:
 393:vec9_io.c     **** 
 2024               		.loc 1 393 0
 2025 02e4 8091 0000 		lds r24,keyState
 2026 02e8 9091 0000 		lds r25,keyState+1
 2027 02ec 8093 0000 		sts lastKeyState.3867,r24
 2028 02f0 9093 0000 		sts lastKeyState.3867+1,r25
 395:vec9_io.c     **** 	{
 2029               		.loc 1 395 0
 2030 02f4 83E0      		ldi r24,lo8(3)
 2031 02f6 0E94 0000 		call CheckTimer
 2032               	.LVL83:
 2033 02fa 8823      		tst r24
 2034 02fc 01F0      		breq .L242
 2035               	.LVL84:
 398:vec9_io.c     **** 
 2036               		.loc 1 398 0
 2037 02fe 2091 0806 		lds r18,1544
 2038 0302 2295      		swap r18
 2039 0304 2695      		lsr r18
 2040 0306 2770      		andi r18,lo8(7)
 2041               	.LVL85:
 400:vec9_io.c     **** 
 2042               		.loc 1 400 0
 2043 0308 8091 2806 		lds r24,1576
 2044 030c 38E0      		ldi r19,lo8(8)
 2045 030e 839F      		mul r24,r19
 2046 0310 C001      		movw r24,r0
 2047 0312 1124      		clr __zero_reg__
 2048 0314 AC01      		movw r20,r24
 2049 0316 422B      		or r20,r18
 2050 0318 9A01      		movw r18,r20
 2051               	.LVL86:
 402:vec9_io.c     **** 		
 2052               		.loc 1 402 0
 2053 031a 9091 4806 		lds r25,1608
 2054 031e 9670      		andi r25,lo8(6)
 2055 0320 892F      		mov r24,r25
 2056 0322 90E0      		ldi r25,0
 2057 0324 982F      		mov r25,r24
 2058 0326 8827      		clr r24
 2059 0328 990F      		lsl r25
 2060 032a 822B      		or r24,r18
 2061 032c 932B      		or r25,r19
 2062               	.LVL87:
 404:vec9_io.c     **** 		{
 2063               		.loc 1 404 0
 2064 032e 2091 4806 		lds r18,1608
 2065 0332 20FD      		sbrc r18,0
 406:vec9_io.c     **** 		}
 2066               		.loc 1 406 0
 2067 0334 9061      		ori r25,16
 2068               	.LVL88:
 2069               	.L243:
 408:vec9_io.c     **** 		{
 2070               		.loc 1 408 0
 2071 0336 2091 2806 		lds r18,1576
 2072 033a 27FD      		sbrc r18,7
 410:vec9_io.c     **** 		}
 2073               		.loc 1 410 0
 2074 033c 9062      		ori r25,32
 2075               	.LVL89:
 2076               	.L244:
 413:vec9_io.c     **** 
 2077               		.loc 1 413 0
 2078 033e 8093 0000 		sts keyState,r24
 2079 0342 9093 0000 		sts keyState+1,r25
 423:vec9_io.c     **** 	}
 2080               		.loc 1 423 0
 2081 0346 6EE2      		ldi r22,lo8(46)
 2082 0348 70E0      		ldi r23,0
 2083 034a 83E0      		ldi r24,lo8(3)
 2084               	.LVL90:
 2085 034c 0E94 0000 		call SetTimer
 2086               	.LVL91:
 2087               	.L242:
 426:vec9_io.c     **** 	newKeysReleased=lastKeyState&(keyState^lastKeyState);	// And the ones immediately un-pressed
 2088               		.loc 1 426 0
 2089 0350 8091 0000 		lds r24,lastKeyState.3867
 2090 0354 9091 0000 		lds r25,lastKeyState.3867+1
 2091 0358 2091 0000 		lds r18,keyState
 2092 035c 3091 0000 		lds r19,keyState+1
 2093 0360 AC01      		movw r20,r24
 2094 0362 4095      		com r20
 2095 0364 5095      		com r21
 2096 0366 4223      		and r20,r18
 2097 0368 5323      		and r21,r19
 2098 036a 4093 0000 		sts newKeys,r20
 2099 036e 5093 0000 		sts newKeys+1,r21
 427:vec9_io.c     **** }
 2100               		.loc 1 427 0
 2101 0372 2095      		com r18
 2102 0374 3095      		com r19
 2103 0376 8223      		and r24,r18
 2104 0378 9323      		and r25,r19
 2105 037a 8093 0000 		sts newKeysReleased,r24
 2106 037e 9093 0000 		sts newKeysReleased+1,r25
 2107               	.LBE57:
 2108               	.LBE56:
1336:vec9_io.c     **** 
1337:vec9_io.c     **** 	SetState(DoStartupTest);
1338:vec9_io.c     **** 	//SetState(DoUpdateIo);
1339:vec9_io.c     **** 
1340:vec9_io.c     **** 	while(1)
1341:vec9_io.c     **** 	{
1342:vec9_io.c     **** 		UpdateAdc();
1343:vec9_io.c     **** 		HandleSwitches();
1344:vec9_io.c     **** 		State();	// Execute the current program state
 2109               		.loc 1 1344 0
 2110 0382 E091 0000 		lds r30,State
 2111 0386 F091 0000 		lds r31,State+1
 2112 038a 0995      		icall
 2113               	.LVL92:
1345:vec9_io.c     **** 	}
 2114               		.loc 1 1345 0
 2115 038c 00C0      		rjmp .L245
 2116               		.cfi_endproc
 2117               	.LFE23:
 2119               		.local	lastKeyState.3867
 2120               		.comm	lastKeyState.3867,2,1
 2121               		.data
 2124               	tossCounter.3890:
 2125 0000 04        		.byte	4
 2126               		.local	rxMessageState.3918
 2127               		.comm	rxMessageState.3918,1,1
 2128               		.local	lastOutputByteLow.3939
 2129               		.comm	lastOutputByteLow.3939,1,1
 2130               		.local	lastOutputByteMiddle.3938
 2131               		.comm	lastOutputByteMiddle.3938,1,1
 2132               		.local	lastOutputByteHigh.3937
 2133               		.comm	lastOutputByteHigh.3937,1,1
 2134               		.local	lampCounter.3941
 2135               		.comm	lampCounter.3941,1,1
 2136               		.local	shiftIndex.3940
 2137               		.comm	shiftIndex.3940,1,1
 2138               		.local	analogPitch
 2139               		.comm	analogPitch,1,1
 2140               		.local	analogRoll
 2141               		.comm	analogRoll,1,1
 2142               		.local	outputByteLow
 2143               		.comm	outputByteLow,1,1
 2144               		.local	outputByteMiddle
 2145               		.comm	outputByteMiddle,1,1
 2146               		.local	outputByteHigh
 2147               		.comm	outputByteHigh,1,1
 2148               		.local	adcSampleCount
 2149               		.comm	adcSampleCount,1,1
 2150               		.local	adcResultTemp
 2151               		.comm	adcResultTemp,4,1
 2152               		.local	currentAdcSource
 2153               		.comm	currentAdcSource,1,1
 2154               		.local	newAdcResult
 2155               		.comm	newAdcResult,2,1
 2156               		.local	adcResults
 2157               		.comm	adcResults,4,1
 2158               		.local	newKeysReleased
 2159               		.comm	newKeysReleased,2,1
 2160               		.local	newKeys
 2161               		.comm	newKeys,2,1
 2162               		.local	keyState
 2163               		.comm	keyState,2,1
 2164               		.local	bytesInRxFifo
 2165               		.comm	bytesInRxFifo,1,1
 2166               		.local	dump
 2167               		.comm	dump,1,1
 2168               		.local	fifoWritePointer
 2169               		.comm	fifoWritePointer,1,1
 2170               		.local	fifoReadPointer
 2171               		.comm	fifoReadPointer,1,1
 2172               		.local	rxFifo
 2173               		.comm	rxFifo,64,1
 2174               		.local	txBytesToSend
 2175               		.comm	txBytesToSend,1,1
 2176               		.local	txBufferIndex
 2177               		.comm	txBufferIndex,1,1
 2178               		.local	txBuffer
 2179               		.comm	txBuffer,16,1
 2180               		.text
 2181               	.Letext0:
 2182               		.file 2 "/home/avrToolchain/avr/include/stdint.h"
 2183               		.file 3 "/home/avrToolchain/avr/include/stdio.h"
 2184               		.file 4 "/home/avrToolchain/avr/include/avr/iox64a3.h"
 2185               		.file 5 "defines.h"
 2186               		.file 6 "globals.h"
 2187               		.file 7 "softclock.h"
 2188               		.file 8 "uart.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 vec9_io.c
     /tmp/ccWg286t.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccWg286t.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccWg286t.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccWg286t.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccWg286t.s:6      *ABS*:0000000000000034 __CCP__
     /tmp/ccWg286t.s:7      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccWg286t.s:8      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccWg286t.s:13     .text:0000000000000000 CCPWrite
     /tmp/ccWg286t.s:61     .text:0000000000000018 UartPutChar
     /tmp/ccWg286t.s:101    .text:000000000000003a SetOutputs
     /tmp/ccWg286t.s:2145   .bss:000000000000000c outputByteHigh
     /tmp/ccWg286t.s:2143   .bss:000000000000000b outputByteMiddle
     /tmp/ccWg286t.s:2141   .bss:000000000000000a outputByteLow
     /tmp/ccWg286t.s:371    .text:000000000000019e DoStartupTest
     /tmp/ccWg286t.s:2135   .bss:0000000000000007 shiftIndex.3940
     /tmp/ccWg286t.s:2133   .bss:0000000000000006 lampCounter.3941
     /tmp/ccWg286t.s:2131   .bss:0000000000000005 lastOutputByteHigh.3937
     /tmp/ccWg286t.s:2129   .bss:0000000000000004 lastOutputByteMiddle.3938
     /tmp/ccWg286t.s:2127   .bss:0000000000000003 lastOutputByteLow.3939
     /tmp/ccWg286t.s:2161   .bss:000000000000001d keyState
     /tmp/ccWg286t.s:2157   .bss:0000000000000019 newKeysReleased
     /tmp/ccWg286t.s:2153   .bss:0000000000000013 newAdcResult
     /tmp/ccWg286t.s:2155   .bss:0000000000000015 adcResults
     /tmp/ccWg286t.s:2137   .bss:0000000000000008 analogPitch
     /tmp/ccWg286t.s:2139   .bss:0000000000000009 analogRoll
     /tmp/ccWg286t.s:2163   .bss:000000000000001f bytesInRxFifo
     /tmp/ccWg286t.s:1313   .text:00000000000006f6 DoUpdateIo
     /tmp/ccWg286t.s:1074   .text:00000000000005fc SetState
     /tmp/ccWg286t.s:1094   .text:000000000000060a __vector_default
     /tmp/ccWg286t.s:1131   .text:0000000000000622 __vector_47
     /tmp/ccWg286t.s:1178   .text:0000000000000650 __vector_119
     /tmp/ccWg286t.s:2167   .bss:0000000000000021 fifoWritePointer
     /tmp/ccWg286t.s:2171   .bss:0000000000000023 rxFifo
     /tmp/ccWg286t.s:2165   .bss:0000000000000020 dump
     /tmp/ccWg286t.s:1260   .text:00000000000006ba GetByteFromRxFifo
     /tmp/ccWg286t.s:2169   .bss:0000000000000022 fifoReadPointer
     /tmp/ccWg286t.s:2120   .bss:0000000000000002 rxMessageState.3918
     /tmp/ccWg286t.s:2173   .bss:0000000000000063 txBytesToSend
     /tmp/ccWg286t.s:2177   .bss:0000000000000065 txBuffer
     /tmp/ccWg286t.s:2175   .bss:0000000000000064 txBufferIndex
     /tmp/ccWg286t.s:1545   .text:0000000000000836 __vector_64
     /tmp/ccWg286t.s:1582   .text.startup:0000000000000000 main
     /tmp/ccWg286t.s:2149   .bss:000000000000000e adcResultTemp
     /tmp/ccWg286t.s:2147   .bss:000000000000000d adcSampleCount
     /tmp/ccWg286t.s:2151   .bss:0000000000000012 currentAdcSource
     /tmp/ccWg286t.s:2159   .bss:000000000000001b newKeys
     /tmp/ccWg286t.s:2124   .data:0000000000000000 tossCounter.3890
                             .bss:0000000000000000 lastKeyState.3867

UNDEFINED SYMBOLS
subState
SetTimer
CheckTimer
State
systemTicks
UartTxBufferReady
UartSendByte
InitUart
fdevopen
printf
__do_copy_data
__do_clear_bss
